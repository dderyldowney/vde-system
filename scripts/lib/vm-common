#!/usr/bin/env zsh
# VM Common Library for VDE Management Scripts
# Source this library with: source ./scripts/lib/vm-common
# Requires: zsh 5.0+ for associative arrays

# -----------------------
# Constants
# -----------------------
# Get the directory where this script is located
if [[ -n "${ZSH_VERSION:-}" ]]; then
    # Zsh compatibility - ${(%):-%x} is the current script path
    readonly VDE_ROOT_DIR="$(cd "$(dirname "${(%):-%x}")/../.." && pwd)"
else
    # Bash compatibility - ${BASH_SOURCE[0]} is the current script path
    readonly VDE_ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
fi

readonly CONFIGS_DIR="$VDE_ROOT_DIR/configs/docker"
readonly SCRIPTS_DIR="$VDE_ROOT_DIR/scripts"
readonly TEMPLATES_DIR="$SCRIPTS_DIR/templates"
readonly DATA_DIR="$SCRIPTS_DIR/data"
readonly BACKUP_DIR="$VDE_ROOT_DIR/backup"
readonly VM_TYPES_CONF="$DATA_DIR/vm-types.conf"

# Port ranges
readonly LANG_PORT_START=2200
readonly LANG_PORT_END=2299
readonly SVC_PORT_START=2400
readonly SVC_PORT_END=2499

# -----------------------
# Logging Functions
# -----------------------
log_info() {
    echo "[INFO] $*"
}

log_error() {
    echo "[ERROR] $*" >&2
}

log_success() {
    echo "[SUCCESS] $*"
}

# -----------------------
# Config Loading Functions
# -----------------------
# Declare associative arrays for VM type data
typeset -gA VM_TYPE
typeset -gA VM_ALIASES
typeset -gA VM_DISPLAY
typeset -gA VM_INSTALL
typeset -gA VM_SVC_PORT

load_vm_types() {
    local conf_file="$VM_TYPES_CONF"

    if [[ ! -f "$conf_file" ]]; then
        log_error "VM types config not found: $conf_file"
        return 1
    fi

    # Clear existing associative arrays using unset
    unset VM_TYPE VM_ALIASES VM_DISPLAY VM_INSTALL VM_SVC_PORT
    typeset -gA VM_TYPE VM_ALIASES VM_DISPLAY VM_INSTALL VM_SVC_PORT

    # Skip comments and empty lines
    while IFS='|' read -r type name vm_aliases display install svc_port; do
        # Skip comments and empty lines
        [[ "$type" =~ ^#.*$ ]] && continue
        [[ -z "$type" ]] && continue

        VM_TYPE[$name]="$type"
        VM_ALIASES[$name]="$vm_aliases"
        VM_DISPLAY[$name]="$display"
        VM_INSTALL[$name]="$install"
        VM_SVC_PORT[$name]="$svc_port"
    done < "$conf_file"

    return 0
}

# -----------------------
# VM Info Query Function
# -----------------------
get_vm_info() {
    local field=$1
    local name=$2

    case "$field" in
        type)
            echo "${VM_TYPE[$name]:-}"
            ;;
        aliases)
            echo "${VM_ALIASES[$name]:-}"
            ;;
        display)
            echo "${VM_DISPLAY[$name]:-}"
            ;;
        install)
            echo "${VM_INSTALL[$name]:-}"
            ;;
        svc_port)
            echo "${VM_SVC_PORT[$name]:-}"
            ;;
        *)
            log_error "Unknown field: $field"
            return 1
            ;;
    esac
}

# -----------------------
# VM Discovery Functions
# -----------------------
get_all_vms() {
    for name in "${(@k)VM_TYPE}"; do
        echo "$name"
    done | sort
}

get_lang_vms() {
    for name in "${(@k)VM_TYPE}"; do
        if [[ "${VM_TYPE[$name]}" == "lang" ]]; then
            echo "$name"
        fi
    done | sort
}

get_service_vms() {
    for name in "${(@k)VM_TYPE}"; do
        if [[ "${VM_TYPE[$name]}" == "service" ]]; then
            echo "$name"
        fi
    done | sort
}

is_known_vm() {
    local vm=$1
    [[ -n "${VM_TYPE[$vm]:-}" ]]
}

is_vm_type() {
    local vm=$1
    local expected_type=$2
    [[ "${VM_TYPE[$vm]:-}" == "$expected_type" ]]
}

vm_exists() {
    local vm=$1
    local compose_file="$CONFIGS_DIR/$vm/docker-compose.yml"
    [[ -f "$compose_file" ]]
}

resolve_vm_name() {
    local input=$1

    # Direct match
    if is_known_vm "$input"; then
        echo "$input"
        return 0
    fi

    # Check vm_aliases
    for name in "${(@k)VM_TYPE}"; do
        local vm_aliases="${VM_ALIASES[$name]}"
        if [[ ",$vm_aliases," =~ ",$input," ]]; then
            echo "$name"
            return 0
        fi
    done

    return 1
}

# -----------------------
# Port Management Functions
# -----------------------
get_vm_ssh_port() {
    local vm=$1
    local compose_file="$CONFIGS_DIR/$vm/docker-compose.yml"

    if [[ ! -f "$compose_file" ]]; then
        return 1
    fi

    # Extract the SSH port mapping (format: "XXXX:22")
    local port_line
    port_line=$(grep -E '^\s+-\s+"[0-9]+:22"' "$compose_file" | head -1)

    if [[ -z "$port_line" ]]; then
        return 1
    fi

    # Extract port number before ":22"
    local port
    port=$(echo "$port_line" | sed 's/.*"\([0-9]*\):22".*/\1/')
    echo "$port"
}

get_allocated_ports() {
    local range_start=$1
    local range_end=$2

    local ports=()
    local compose_file

    for compose_dir in "$CONFIGS_DIR"/*/; do
        compose_file="$compose_dir/docker-compose.yml"
        if [[ -f "$compose_file" ]]; then
            while IFS= read -r line; do
                if [[ "$line" =~ ([0-9]+):22 ]]; then
                    local port="$match[1]"
                    if [[ $port -ge $range_start && $port -le $range_end ]]; then
                        ports+=("$port")
                    fi
                fi
            done < "$compose_file"
        fi
    done

    # Sort and deduplicate
    printf '%s\n' "${ports[@]}" | sort -n | uniq
}

find_next_available_port() {
    local vm_type=$1
    local range_start range_end

    case "$vm_type" in
        lang)
            range_start=$LANG_PORT_START
            range_end=$LANG_PORT_END
            ;;
        service)
            range_start=$SVC_PORT_START
            range_end=$SVC_PORT_END
            ;;
        *)
            log_error "Unknown VM type: $vm_type"
            return 1
            ;;
    esac

    local -a allocated_ports
    allocated_ports=($(get_allocated_ports "$range_start" "$range_end"))

    for ((port=range_start; port<=range_end; port++)); do
        if [[ ! " ${allocated_ports[@]} " =~ " ${port} " ]]; then
            echo "$port"
            return 0
        fi
    done

    log_error "No available ports in range $range_start-$range_end"
    return 1
}

# -----------------------
# Docker Compose Functions
# -----------------------
get_compose_file() {
    local vm=$1
    echo "$CONFIGS_DIR/$vm/docker-compose.yml"
}

build_docker_opts() {
    local rebuild=$1
    local nocache=$2

    local opts=""
    if [[ "$rebuild" == "true" ]]; then
        opts="--build"
        if [[ "$nocache" == "true" ]]; then
            opts="$opts --no-cache"
        fi
    fi
    echo "$opts"
}

start_vm() {
    local vm=$1
    local rebuild=$2
    local nocache=$3

    local compose_file
    compose_file=$(get_compose_file "$vm")

    if [[ ! -f "$compose_file" ]]; then
        log_error "Docker compose file not found: $compose_file"
        return 1
    fi

    log_info "Starting $vm..."

    local build_opts
    build_opts=$(build_docker_opts "$rebuild" "$nocache")

    docker-compose -f "$compose_file" up -d $build_opts
}

stop_vm() {
    local vm=$1

    local compose_file
    compose_file=$(get_compose_file "$vm")

    if [[ ! -f "$compose_file" ]]; then
        log_error "Docker compose file not found: $compose_file"
        return 1
    fi

    log_info "Shutting down $vm..."
    docker-compose -f "$compose_file" down
}

# -----------------------
# Template Processing Functions
# -----------------------
# render_template takes a template file and variable name-value pairs
# Usage: render_template template_file NAME "value" OTHER "value"
render_template() {
    local template_file=$1
    shift

    if [[ ! -f "$template_file" ]]; then
        log_error "Template not found: $template_file"
        return 1
    fi

    local content
    content=$(cat "$template_file")

    # Parse variable name-value pairs
    while [[ $# -ge 2 ]]; do
        local var_name="$1"
        local var_value="$2"
        shift 2

        # Escape special characters for sed replacement
        var_value=$(printf '%s\n' "$var_value" | sed 's/[&/\]/\\&/g')
        content=$(echo "$content" | sed "s/{{$var_name}}/$var_value/g")
    done

    echo "$content"
}

# -----------------------
# SSH Key Management Functions
# -----------------------

# Detect all available SSH private keys in ~/.ssh/
# Returns a newline-separated list of key filepaths
detect_ssh_keys() {
    local ssh_dir="$HOME/.ssh"
    local found_keys=()

    # Common SSH key patterns (private keys only)
    local key_patterns=(
        "id_ed25519"
        "id_rsa"
        "id_ecdsa"
        "id_ecdsa_sk"
        "id_ed25519_sk"
        "id_dsa"  # Deprecated but still supported
    )

    # Check for each key pattern
    for key_name in "${key_patterns[@]}"; do
        local key_path="$ssh_dir/$key_name"
        if [[ -f "$key_path" && -r "$key_path" ]]; then
            # Verify it's actually a private key (not a .pub file)
            if [[ "$key_path" != *.pub ]]; then
                # Check if corresponding .pub file exists (valid keypair)
                if [[ -f "${key_path}.pub" ]]; then
                    found_keys+=("$key_path")
                fi
            fi
        fi
    done

    # Also check for any custom key names (ssh-keygen -t rsa -f mykey)
    # Look for files that don't match standard patterns but have .pub files
    setopt local_options null_glob
    for key_file in "$ssh_dir"/*; do
        local basename="${key_file:t}"
        # Skip if it's a pubkey, config, or known_hosts file
        if [[ "$basename" == *.pub ]] || \
           [[ "$basename" == "config" ]] || \
           [[ "$basename" == "known_hosts" ]] || \
           [[ "$basename" == "authorized_keys" ]] || \
           [[ "$basename" == *.backup.* ]]; then
            continue
        fi

        # Check if this is a private key with a corresponding pubkey
        if [[ -f "${key_file}.pub" ]]; then
            # Check if already in our list
            local already_found=false
            for found in "${found_keys[@]}"; do
                if [[ "$found" == "$key_file" ]]; then
                    already_found=true
                    break
                fi
            done
            if [[ "$already_found" == "false" ]]; then
                found_keys+=("$key_file")
            fi
        fi
    done

    # Output all found keys
    for key in "${found_keys[@]}"; do
        echo "$key"
    done
}

# Get the primary/default SSH key to use for VDE
# Returns the filepath of the best key to use
get_primary_ssh_key() {
    local -a keys
    keys=("${(@f)$(detect_ssh_keys)}")

    if [[ ${#keys[@]} -eq 0 ]]; then
        return 1
    fi

    # If only one key, use it
    if [[ ${#keys[@]} -eq 1 ]]; then
        echo "${keys[1]}"
        return 0
    fi

    # Multiple keys: try to determine the best one
    # Priority: ed25519 > ecdsa > rsa > dsa
    local -a preferred_keys=(
        "id_ed25519"
        "id_ecdsa"
        "id_rsa"
        "id_dsa"
    )

    # Check for preferred keys in priority order
    for preferred in "${preferred_keys[@]}"; do
        for key in "${keys[@]}"; do
            local basename="${key:t}"
            if [[ "$basename" == "$preferred" ]]; then
                echo "$key"
                return 0
            fi
        done
    done

    # If no preferred key found, use the first one
    echo "${keys[1]}"
    return 0
}

# Get the corresponding public key file for a private key
get_ssh_pubkey() {
    local private_key="$1"

    if [[ -f "${private_key}.pub" ]]; then
        echo "${private_key}.pub"
        return 0
    fi

    return 1
}

# Sync SSH public keys to VDE's public-ssh-keys directory
# This ensures all user's public keys are available for container auth
sync_ssh_keys_to_vde() {
    local public_keys_dir="$VDE_ROOT_DIR/public-ssh-keys"
    local keys_copied=0
    local -a keys

    # Ensure directory exists
    mkdir -p "$public_keys_dir"

    # Get all private keys and copy their public keys
    keys=("${(@f)$(detect_ssh_keys)}")

    if [[ ${#keys[@]} -eq 0 ]]; then
        log_error "No SSH keys found. Please generate an SSH key first."
        log_error "Recommended: ssh-keygen -t ed25519"
        return 1
    fi

    log_info "Syncing ${#keys[@]} SSH key(s) to VDE..."

    # Copy each public key
    for private_key in "${keys[@]}"; do
        local pubkey
        pubkey=$(get_ssh_pubkey "$private_key")

        if [[ -n "$pubkey" && -f "$pubkey" ]]; then
            local key_name="${pubkey:t}"
            local dest_path="$public_keys_dir/$key_name"

            # Copy the public key
            cp "$pubkey" "$dest_path"
            chmod 644 "$dest_path"
            ((keys_copied++))
            log_info "  âœ“ Copied: $key_name"
        fi
    done

    # Create .keep file if it doesn't exist (for git tracking)
    if [[ ! -f "$public_keys_dir/.keep" ]]; then
        touch "$public_keys_dir/.keep"
    fi

    log_info "Synced $keys_copied public key(s) to: $public_keys_dir"
    return 0
}

# Validate that at least one SSH key exists
# If no keys exist, offer to generate one
validate_or_create_ssh_key() {
    local -a keys
    keys=("${(@f)$(detect_ssh_keys)}")

    if [[ ${#keys[@]} -gt 0 ]]; then
        log_info "Found ${#keys[@]} SSH key(s)"
        return 0
    fi

    # No keys found - offer to generate one
    log_warning "No SSH keys found in ~/.ssh/"
    log_warning "VDE requires SSH keys for container authentication."

    # Check if we're in an interactive terminal
    if [[ -t 0 ]]; then
        echo ""
        echo "Would you like to generate an SSH key now? [Y/n]"
        read -r response
        response=${response:-Y}

        if [[ "$response" =~ ^[Yy]$ ]]; then
            # Generate ed25519 key (recommended)
            local key_path="$HOME/.ssh/id_ed25519"

            log_info "Generating SSH key: $key_path"
            ssh-keygen -t ed25519 -f "$key_path" -N "" -C "$(whoami)@$(hostname)-vde"

            if [[ $? -eq 0 ]]; then
                log_info "SSH key generated successfully!"
                log_info "Private key: $key_path"
                log_info "Public key: ${key_path}.pub"

                # Copy to VDE
                sync_ssh_keys_to_vde
                return 0
            else
                log_error "Failed to generate SSH key"
                return 1
            fi
        else
            log_error "SSH key required for VDE to function"
            return 1
        fi
    else
        # Non-interactive mode
        log_error "No SSH keys found. Run: ssh-keygen -t ed25519"
        return 1
    fi
}

# Get the identity file path to use for SSH connections
# This detects the user's primary key automatically
get_ssh_identity_file() {
    local primary_key
    primary_key=$(get_primary_ssh_key)

    if [[ -n "$primary_key" && -f "$primary_key" ]]; then
        echo "$primary_key"
        return 0
    fi

    # Fallback to default (for backward compatibility)
    echo "$HOME/.ssh/id_ed25519"
    return 0
}

# -----------------------
# SSH Config Functions
# -----------------------
get_user_ssh_config() {
    echo "$HOME/.ssh/config"
}

backup_ssh_config() {
    local ssh_config="$HOME/.ssh/config"
    local backup_path="$BACKUP_DIR/ssh/config.backup.$(date +%Y%m%d_%H%M%S)"

    if [[ -f "$ssh_config" ]]; then
        cp "$ssh_config" "$backup_path"
        log_info "Backed up SSH config to: $backup_path"
    fi
}

ssh_config_has_entry() {
    local host_alias=$1
    local ssh_config="$HOME/.ssh/config"

    if [[ ! -f "$ssh_config" ]]; then
        return 1
    fi

    grep -q "^Host $host_alias$" "$ssh_config"
}

generate_ssh_config_entry() {
    local host=$1
    local port=$2
    local display_name=$3
    local identity_file="${4:-$(get_ssh_identity_file)}"

    local template_file="$TEMPLATES_DIR/ssh-entry.txt"
    render_template "$template_file" HOST "$host" SSH_PORT "$port" COMMENT "$display_name Dev VM" IDENTITY_FILE "$identity_file"
}

merge_ssh_config_entry() {
    local host_alias=$1
    local port=$2
    local display_name=$3
    local identity_file="${4:-$(get_ssh_identity_file)}"
    local ssh_config="$HOME/.ssh/config"

    # Ensure .ssh directory exists
    mkdir -p "$(dirname "$ssh_config")"

    # Create file if it doesn't exist
    if [[ ! -f "$ssh_config" ]]; then
        touch "$ssh_config"
        chmod 600 "$ssh_config"
    fi

    # Check if entry already exists
    if ssh_config_has_entry "$host_alias"; then
        log_error "SSH config entry for '$host_alias' already exists"
        return 1
    fi

    # Backup existing config
    backup_ssh_config

    # Generate new entry
    local entry
    entry=$(generate_ssh_config_entry "$host_alias" "$port" "$display_name" "$identity_file")

    # Append new entry
    echo "" >> "$ssh_config"
    echo "$entry" >> "$ssh_config"

    log_success "Added SSH config entry for '$host_alias'"
    return 0
}

# -----------------------
# Validation Functions
# -----------------------
validate_vm_name() {
    local name=$1

    if [[ -z "$name" ]]; then
        log_error "VM name cannot be empty"
        return 1
    fi

    if [[ ! "$name" =~ ^[a-z0-9]+$ ]]; then
        log_error "VM name must be lowercase alphanumeric (no spaces, hyphens, or special chars)"
        return 1
    fi

    return 0
}

validate_vm_doesnt_exist() {
    local vm=$1

    if vm_exists "$vm"; then
        log_error "VM '$vm' already exists (config found at: $CONFIGS_DIR/$vm/)"
        return 1
    fi
    return 0
}

validate_ssh_key_exists() {
    # Use the new comprehensive validation function
    validate_or_create_ssh_key
}

# Check if SSH agent is running
ssh_agent_is_running() {
    [[ -n "$SSH_AUTH_SOCK" ]] && [[ -S "$SSH_AUTH_SOCK" ]]
}

# Start SSH agent silently if not running
# This is the seamless, automatic function used by VDE scripts
ensure_ssh_agent() {
    # If already running, nothing to do
    if ssh_agent_is_running; then
        return 0
    fi

    # Start SSH agent silently
    eval "$(ssh-agent -s)" >/dev/null 2>&1
    export SSH_AUTH_SOCK

    # Add all available keys to the agent
    local -a keys
    keys=("${(@f)$(detect_ssh_keys)}")

    if [[ ${#keys[@]} -eq 0 ]]; then
        # No keys found - generate one automatically
        log_info "Generating SSH key for VDE..."
        ssh-keygen -t ed25519 -f "$HOME/.ssh/id_ed25519" -N "" -C "$(whoami)@$(hostname)-vde" >/dev/null 2>&1
        sync_ssh_keys_to_vde >/dev/null 2>&1
        keys=("${(@f)$(detect_ssh_keys)}")
    fi

    # Try to add keys silently (will prompt for passphrase if needed)
    local keys_added=0
    for key in "${keys[@]}"; do
        if ssh-add "$key" >/dev/null 2>&1; then
            ((keys_added++))
        fi
    done

    return 0
}

# Verbose version of ensure_ssh_agent for user-facing scripts
# Shows what's happening and offers to set up auto-start
setup_ssh_agent_interactive() {
    if ssh_agent_is_running; then
        log_success "SSH agent running"
        return 0
    fi

    log_info "Starting SSH agent..."
    ensure_ssh_agent

    # Show what was set up
    local -a keys
    keys=("${(@f)$(detect_ssh_keys)}")
    log_success "SSH agent ready with ${#keys[@]} key(s)"
}

# Ensure SSH agent and VM config are set up (called by VM operations)
ensure_ssh_environment() {
    # Ensure SSH agent is running
    ensure_ssh_agent

    # Ensure VM-to-VM SSH config exists
    if [[ ! -f "$HOME/.ssh/config" ]] || ! grep -q "python-dev" "$HOME/.ssh/config" 2>/dev/null; then
        generate_vm_ssh_config >/dev/null 2>&1
    fi

    return 0
}

# Generate SSH config entries for VM-to-VM communication
generate_vm_ssh_config() {
    local ssh_config="$HOME/.ssh/config"
    local need_update=false

    # Ensure .ssh directory and config exist
    mkdir -p "$(dirname "$ssh_config")"
    if [[ ! -f "$ssh_config" ]]; then
        touch "$ssh_config"
        chmod 600 "$ssh_config"
    fi

    # Backup existing config
    backup_ssh_config

    log_info "Generating VM-to-VM SSH config entries..."

    # Get all VMs
    local -a vms
    vms=("${(@f)$(list_all_vms)}")

    for vm in "${vms[@]}"; do
        local vm_type
        vm_type=$(get_vm_info type "$vm")

        if [[ "$vm_type" == "lang" ]]; then
            local vm_alias="${vm}-dev"
            local ssh_port=$(get_vm_ssh_port "$vm")

            if [[ -n "$ssh_port" ]]; then
                # Check if entry already exists
                if ! ssh_config_has_entry "$vm_alias"; then
                    merge_ssh_config_entry "$vm_alias" "localhost" "$vm" "$(get_ssh_identity_file)"
                    need_update=true
                fi
            fi
        fi
    done

    if [[ "$need_update" == "false" ]]; then
        log_info "All VM SSH config entries already up to date"
    fi

    return 0
}

# Get SSH port for a VM
get_vm_ssh_port() {
    local vm=$1
    local compose_file="$CONFIGS_DIR/$vm/docker-compose.yml"

    if [[ ! -f "$compose_file" ]]; then
        return 1
    fi

    grep ':22' "$compose_file" | grep -oE '[0-9]+' | head -1
}

# -----------------------
# Directory Creation Functions
# -----------------------
ensure_vm_directories() {
    local vm=$1
    local vm_type=$2

    local dirs=()

    if [[ "$vm_type" == "lang" ]]; then
        dirs=(
            "$CONFIGS_DIR/$vm"
            "$VDE_ROOT_DIR/projects/$vm"
            "$VDE_ROOT_DIR/logs/$vm"
        )
    else
        dirs=(
            "$CONFIGS_DIR/$vm"
            "$VDE_ROOT_DIR/data/$vm"
            "$VDE_ROOT_DIR/logs/$vm"
        )
    fi

    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
            log_info "Created directory: $dir"
        fi
    done
}

# -----------------------
# Usage Functions
# -----------------------
show_known_vms() {
    echo "Known language VMs:"
    get_lang_vms | sed 's/^/  /'
    echo ""
    echo "Known service VMs:"
    get_service_vms | sed 's/^/  /'
}

# Auto-load VM types when library is sourced
load_vm_types
