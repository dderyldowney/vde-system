#!/usr/bin/env zsh
# VDE Shell Compatibility Layer
# Provides zsh-native abstractions for shell features
# Source this library with: source ./scripts/lib/vde-shell-compat
#
# This library provides zsh-native implementations for:
# - Shell detection functions
# - Associative array operations
# - Script path detection
# - Array iteration
#
# Minimum Requirements:
# - zsh 5.0+
#
# Return Codes:
#   0 - Success
#   1 - General error
#   2 - Invalid input
#   3 - Not found

# =============================================================================
# SHELL DETECTION
# =============================================================================

# _detect_shell - Detect the current shell type
# Returns: "zsh" or "unknown"
# Example: shell=$(_detect_shell)
_detect_shell() {
    if [ -n "${ZSH_VERSION:-}" ]; then
        echo "zsh"
    else
        echo "unknown"
    fi
}

# _shell_version - Get the current shell version
# Returns: Version string (e.g., "5.8" for zsh)
# Example: version=$(_shell_version)
_shell_version() {
    if [ -n "${ZSH_VERSION:-}" ]; then
        echo "$ZSH_VERSION"
    else
        echo "unknown"
    fi
}

# _is_zsh - Check if running in zsh
# Returns: 0 if zsh, 1 otherwise
# Example: _is_zsh && echo "Running in zsh"
_is_zsh() {
    [ -n "${ZSH_VERSION:-}" ]
}

# _shell_supports_native_assoc - Check if shell supports native associative arrays
# Returns: 0 if supported (always true for zsh 5.0+)
# Note: zsh 5.0+ supports native associative arrays
_shell_supports_native_assoc() {
    return 0
}

# =============================================================================
# PORTABLE SCRIPT PATH DETECTION
# =============================================================================

# _get_script_path - Get the path of the currently executing script
# Returns: Absolute path to the current script
# Example: script_path=$(_get_script_path)
_get_script_path() {
    # zsh: Use ${(%):-%x} expansion
    # shellcheck disable=SC2296
    echo "${(%):-%x}"
}

# _get_script_dir - Get the directory containing the current script
# Returns: Absolute path to the script's directory
# Example: script_dir=$(_get_script_dir)
_get_script_dir() {
    local script_path
    script_path=$(_get_script_path)
    
    # Handle relative paths
    if [ "${script_path#/}" = "$script_path" ]; then
        # Relative path - prepend PWD
        script_path="$PWD/$script_path"
    fi
    
    # Get directory
    local dir
    dir=$(dirname "$script_path")
    
    # Resolve to absolute path if possible
    if [ -d "$dir" ]; then
        (cd "$dir" && pwd)
    else
        echo "$dir"
    fi
}

# =============================================================================
# ASSOCIATIVE ARRAY OPERATIONS
# =============================================================================

# _assoc_init - Initialize an associative array
# Args: <array_name>
# Returns: 0 on success
# Example: _assoc_init "MY_ARRAY"
_assoc_init() {
    local array_name="$1"
    eval "typeset -gA $array_name"
    return 0
}

# _assoc_set - Set a value in an associative array
# Args: <array_name> <key> <value>
# Returns: 0 on success
# Example: _assoc_set "MY_ARRAY" "foo" "bar"
_assoc_set() {
    local array_name="$1"
    local key="$2"
    local value="$3"
    eval "${array_name}[\$key]=\$value"
    return 0
}

# _assoc_get - Get a value from an associative array
# Args: <array_name> <key>
# Returns: 0 on success (outputs value to stdout), 1 if key not found
# Example: value=$(_assoc_get "MY_ARRAY" "foo")
_assoc_get() {
    local array_name="$1"
    local key="$2"
    local value
    local keys

    eval "keys=\" \${(k)${array_name}} \""
    case "$keys" in
        *" $key "*)
            eval "value=\"\${${array_name}[\$key]}\""
            echo "$value"
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# _assoc_keys - Get all keys from an associative array
# Args: <array_name>
# Returns: 0 on success (outputs keys to stdout, one per line)
# Example: for k in $(_assoc_keys "MY_ARRAY"); do echo "$k"; done
_assoc_keys() {
    local array_name="$1"

    case "$array_name" in
        VM_TYPE)
            for k in ${(k)VM_TYPE}; do echo "$k"; done
            ;;
        VM_ALIASES)
            for k in ${(k)VM_ALIASES}; do echo "$k"; done
            ;;
        VM_DISPLAY)
            for k in ${(k)VM_DISPLAY}; do echo "$k"; done
            ;;
        VM_INSTALL)
            for k in ${(k)VM_INSTALL}; do echo "$k"; done
            ;;
        VM_SVC_PORT)
            for k in ${(k)VM_SVC_PORT}; do echo "$k"; done
            ;;
        PORT_REGISTRY)
            for k in ${(k)PORT_REGISTRY}; do echo "$k"; done
            ;;
        *)
            for k in ${(kP)array_name[@]}; do echo "$k"; done
    esac
    return 0
}

# _assoc_has_key - Check if a key exists in an associative array
# Args: <array_name> <key>
# Returns: 0 if key exists, 1 otherwise
# Example: _assoc_has_key "MY_ARRAY" "foo" && echo "Key exists"
_assoc_has_key() {
    local array_name="$1"
    local key="$2"
    local keys

    eval "keys=\" \${(k)${array_name}} \""
    case "$keys" in
        *" $key "*) return 0 ;;
        *) return 1 ;;
    esac
}

# _assoc_unset - Remove a key from an associative array
# Args: <array_name> <key>
# Returns: 0 on success
# Example: _assoc_unset "MY_ARRAY" "foo"
_assoc_unset() {
    local array_name="$1"
    local key="$2"
    eval "unset \"${array_name}[$key]\""
    return 0
}

# _assoc_clear - Clear all entries from an associative array
# Args: <array_name>
# Returns: 0 on success
# Example: _assoc_clear "MY_ARRAY"
_assoc_clear() {
    local array_name="$1"
    eval "unset $array_name; typeset -gA $array_name"
    return 0
}

# _assoc_cleanup - Cleanup function (no-op for zsh native arrays)
# Args: none
# Returns: 0 on success
# Example: trap '_assoc_cleanup' EXIT
_assoc_cleanup() {
    return 0
}

# =============================================================================
# ARRAY OPERATIONS
# =============================================================================

# _array_length - Get the length of an indexed array
# Args: <array_name>
# Returns: 0 on success (outputs length to stdout)
# Example: len=$(_array_length "MY_ARRAY")
_array_length() {
    local array_name="$1"
    eval "echo \${#${array_name}[@]}"
}

# _array_append - Append a value to an indexed array
# Args: <array_name> <value>
# Returns: 0 on success
# Example: _array_append "MY_ARRAY" "new_value"
_array_append() {
    local array_name="$1"
    local value="$2"
    eval "${array_name}+=(\"\$value\")"
    return 0
}

# _array_contains - Check if an array contains a value
# Args: <array_name> <value>
# Returns: 0 if found, 1 otherwise
# Example: _array_contains "MY_ARRAY" "value" && echo "Found"
_array_contains() {
    local array_name="$1"
    local search_value="$2"
    eval "for v in \"\${${array_name}[@]}\"; do [ \"\$v\" = \"\$search_value\" ] && return 0; done"
    return 1
}

# =============================================================================
# STRING OPERATIONS
# =============================================================================

# _string_split - Split a string by delimiter into an array
# Args: <string> <delimiter> <array_name>
# Returns: 0 on success
# Example: _string_split "a,b,c" "," "MY_ARRAY"
_string_split() {
    local string="$1"
    local delimiter="$2"
    local array_name="$3"
    eval "${array_name}=(\${(s:${delimiter}:)string})"
    return 0
}

# _string_trim - Trim leading and trailing whitespace
# Args: <string>
# Returns: 0 on success (outputs trimmed string to stdout)
# Example: trimmed=$(_string_trim "  hello  ")
_string_trim() {
    local string="$1"
    
    # Remove leading whitespace
    string="${string#"${string%%[![:space:]]*}"}"
    # Remove trailing whitespace
    string="${string%"${string##*[![:space:]]}"}"
    
    echo "$string"
}

# =============================================================================
# READ OPERATIONS
# =============================================================================

# _read_array - Read lines into an array
# Args: <array_name>
# Reads from stdin, one element per line
# Returns: 0 on success
# Example: echo -e "a\nb\nc" | _read_array "MY_ARRAY"
_read_array() {
    local array_name="$1"
    eval "${array_name}=()"
    while IFS= read -r line; do
        _array_append "$array_name" "$line"
    done
    return 0
}

# =============================================================================
# SHELL COMPATIBILITY WARNINGS
# =============================================================================

# _check_shell_compatibility - Check and warn about shell compatibility
# Args: none
# Returns: 0 if compatible, 1 if unsupported
# Example: _check_shell_compatibility || exit 1
_check_shell_compatibility() {
    local shell
    shell=$(_detect_shell)
    local version
    version=$(_shell_version)

    case "$shell" in
        zsh)
            local major="${version%%.*}"
            if [ "$major" -lt 5 ]; then
                echo "[ERROR] zsh version $version detected. VDE requires zsh 5.0+" >&2
                return 1
            fi
            ;;
        *)
            echo "[ERROR] VDE requires zsh 5.0+. Current shell: $shell" >&2
            return 1
            ;;
    esac

    return 0
}

# _require_shell - Require zsh or exit
# Args: <shell_name> - must be "zsh"
# Returns: 0 if running in zsh, exits with error otherwise
# Example: _require_shell "zsh"
_require_shell() {
    local required="$1"
    local current
    current=$(_detect_shell)

    if [ "$required" != "zsh" ]; then
        echo "[ERROR] VDE only supports zsh. Requested: $required" >&2
        exit 1
    fi

    if [ "$current" != "zsh" ]; then
        echo "[ERROR] VDE requires zsh but is running in $current" >&2
        exit 1
    fi
    return 0
}

# =============================================================================
# DECLARE/TYPESET WRAPPER
# =============================================================================

# _declare_global - Declare a global variable
# Args: <var_name> [value]
# Returns: 0 on success
# Example: _declare_global "MY_VAR" "value"
_declare_global() {
    local var_name="$1"
    local value="${2:-}"
    eval "typeset -g $var_name=\"\$value\""
    return 0
}

# _declare_global_array - Declare a global indexed array
# Args: <array_name>
# Returns: 0 on success
# Example: _declare_global_array "MY_ARRAY"
_declare_global_array() {
    local array_name="$1"
    eval "typeset -ga $array_name"
    return 0
}

# _declare_global_assoc - Declare a global associative array
# Args: <array_name>
# Returns: 0 on success
# Example: _declare_global_assoc "MY_ASSOC"
_declare_global_assoc() {
    local array_name="$1"
    _assoc_init "$array_name"
}

# =============================================================================
# SETOPT WRAPPER
# =============================================================================

# _enable_nullglob - Enable nullglob (empty result for non-matching globs)
# Args: none
# Returns: 0 on success
# Example: _enable_nullglob
_enable_nullglob() {
    setopt NULL_GLOB
    return 0
}

# _disable_nullglob - Disable nullglob
# Args: none
# Returns: 0 on success
# Example: _disable_nullglob
_disable_nullglob() {
    unsetopt NULL_GLOB
    return 0
}

# =============================================================================
# PORTABLE DATE/TIME OPERATIONS
# =============================================================================

# _date_iso8601 - Get current timestamp in ISO 8601 format
# Returns: ISO 8601 formatted timestamp
# Example: timestamp=$(_date_iso8601)
_date_iso8601() {
    print -P "%D{%Y-%m-%dT%H:%M:%S%z}"
}

# _date_epoch - Get current epoch time in seconds
# Returns: Unix timestamp
# Example: epoch=$(_date_epoch)
_date_epoch() {
    print $EPOCHSECONDS
}

# Export functions for VDE libraries
vde_shell_date_iso8601() { _date_iso8601; }
vde_shell_date_epoch() { _date_epoch; }

# =============================================================================
# INITIALIZATION
# =============================================================================

# Check compatibility on source (can be disabled with VDE_SKIP_COMPAT_CHECK=1)
if [ "${VDE_SKIP_COMPAT_CHECK:-0}" != "1" ]; then
    _check_shell_compatibility
fi
