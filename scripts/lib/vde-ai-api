#!/usr/bin/env zsh
# VDE AI API Client
# Makes API calls to Anthropic or compatible APIs
# Source this library with: source ./scripts/lib/vde-ai-api

# -----------------------
# Dependencies
# -----------------------
# This library requires vm-common to be sourced first (for log functions)

# -----------------------
# Configuration
# -----------------------

# Default API endpoint
readonly DEFAULT_ANTHROPIC_BASE_URL="https://api.anthropic.com"

# Default model
readonly DEFAULT_MODEL="claude-3-5-sonnet-20241022"

# API version
readonly API_VERSION="2023-06-01"

# -----------------------
# Helper Functions
# -----------------------

# Get the effective base URL
# Returns: The base URL to use (from env var or default)
_get_ai_base_url() {
    local base_url="${ANTHROPIC_BASE_URL:-}"
    if [[ -z "$base_url" ]]; then
        echo "$DEFAULT_ANTHROPIC_BASE_URL"
    else
        echo "$base_url"
    fi
}

# Get the effective model to use
# Returns: The model name to use
_get_ai_model() {
    # Check ANTHROPIC_MODEL first (explicit override)
    local model="${ANTHROPIC_MODEL:-}"
    if [[ -n "$model" ]]; then
        echo "$model"
        return
    fi

    # Check ANTHROPIC_DEFAULT_SONNET_MODEL
    model="${ANTHROPIC_DEFAULT_SONNET_MODEL:-}"
    if [[ -n "$model" ]]; then
        echo "$model"
        return
    fi

    # Use default
    echo "$DEFAULT_MODEL"
}

# Get the API key
# Returns: The API key to use
# Priority: ANTHROPIC_AUTH_TOKEN > ANTHROPIC_API_KEY > CLAUDE_API_KEY
_get_ai_api_key() {
    # Check ANTHROPIC_AUTH_TOKEN first (highest priority)
    local key="${ANTHROPIC_AUTH_TOKEN:-}"
    if [[ -n "$key" ]]; then
        echo "$key"
        return
    fi

    # Check ANTHROPIC_API_KEY
    key="${ANTHROPIC_API_KEY:-}"
    if [[ -n "$key" ]]; then
        echo "$key"
        return
    fi

    # Fall back to CLAUDE_API_KEY (legacy support)
    key="${CLAUDE_API_KEY:-}"
    if [[ -n "$key" ]]; then
        echo "$key"
        return
    fi

    # No key found
    return 1
}

# -----------------------
# API Calling
# -----------------------

# Call the Anthropic API with the given prompt
# Args: <prompt> [system_prompt]
# Returns: JSON response from the API
# Exit code: 0 on success, 1 on error
call_ai_api() {
    local prompt="$1"
    local system_prompt="${2:-You are a helpful assistant that parses natural language commands for a Virtual Development Environment (VDE).}"

    # Get API key
    local api_key
    api_key=$(_get_ai_api_key) || {
        log_error "No API key found. Set ANTHROPIC_AUTH_TOKEN, ANTHROPIC_API_KEY, or CLAUDE_API_KEY."
        return 1
    }

    # Get base URL and model
    local base_url
    local model
    base_url=$(_get_ai_base_url)
    model=$(_get_ai_model)

    # Construct the full endpoint URL
    local endpoint="${base_url}/v1/messages"

    # Prepare the request body
    # Using a safe approach for JSON construction
    local request_body
    request_body=$(cat <<EOF
{
  "model": "$model",
  "max_tokens": 1024,
  "system": $(echo "$system_prompt" | jq -Rs .),
  "messages": [
    {
      "role": "user",
      "content": $(echo "$prompt" | jq -Rs .)
    }
  ]
}
EOF
)

    # Make the API call
    local response
    local http_code

    response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        "$endpoint" \
        -H "x-api-key: $api_key" \
        -H "anthropic-version: $API_VERSION" \
        -H "content-type: application/json" \
        -d "$request_body" \
        2>/dev/null)

    # Extract HTTP code from response
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | head -n -1)

    # Check for errors
    if [[ "$http_code" != "200" ]]; then
        log_error "API request failed with HTTP code: $http_code"
        log_error "Response: $response"
        return 1
    fi

    # Check for API errors in response
    if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
        local error_msg
        error_msg=$(echo "$response" | jq -r '.error.message // .error // "Unknown error"')
        log_error "API returned error: $error_msg"
        return 1
    fi

    # Return the response
    echo "$response"
    return 0
}

# Extract the content text from an API response
# Args: <api_response_json>
# Returns: The text content of the message
extract_ai_content() {
    local response="$1"

    # Extract the text content from the response
    echo "$response" | jq -r '.content[0].text // empty'
}

# Parse natural language command using AI
# This function sends the user's command to the AI and returns
# a structured plan that VDE can execute.
#
# Args: <user_input>
# Returns: Structured plan (same format as generate_plan from vde-parser)
# Exit code: 0 on success, 1 on error
parse_command_with_ai() {
    local user_input="$1"

    # System prompt that instructs the AI on how to parse commands
    local system_prompt
    system_prompt='You are a command parser for a Virtual Development Environment (VDE). Your job is to parse natural language commands and return a structured execution plan.

AVAILABLE INTENTS:
- list_vms: List available VMs (filter: lang/svc/all)
- create_vm: Create new VM configuration
- start_vm: Start one or more VMs
- stop_vm: Stop one or more VMs
- restart_vm: Restart one or more VMs (supports rebuild, nocache flags)
- status: Check running status of VMs
- connect: Show connection information for VMs
- help: Show help information

AVAILABLE VMs:
Language VMs: c, cpp, asm, python, rust, js, csharp, ruby, go, java, kotlin, swift, php, scala, r, lua, flutter, elixir, haskell
Service VMs: postgres, redis, mongodb, nginx, couchdb, mysql, rabbitmq

VM ALIASES (map to canonical name):
- python3 → python
- nodejs, node, javascript → js
- golang → go
- c++ → cpp
- postgresql, pg → postgres

OUTPUT FORMAT (exactly one line per field):
INTENT:intent_name
VM:vm1 vm2 vm3
FLAGS:rebuild=true/false nocache=true/false
FILTER:lang/svc/all

RULES:
1. Return ONLY the structured output, no explanations
2. For list_vms intent, use FILTER field (lang/svc/all)
3. For create/start/stop/restart intents, use VM field with space-separated VM names
4. For status/connect, include specific VMs if mentioned, or omit for all
5. Set rebuild=true if user says "rebuild", "re-create"
6. Set nocache=true if user says "no-cache", "no cache"
7. If unknown VM mentioned, still return it - validation happens later
8. Handle "all", "everything", "all languages", "all services" appropriately

Examples:
"what VMs can I create?" → INTENT:list_vms FILTER:all
"create a Go VM" → INTENT:create_vm VM:go FLAGS:rebuild=false nocache=false
"start python and postgres" → INTENT:start_vm VM:python postgres FLAGS:rebuild=false nocache=false
"rebuild rust with no cache" → INTENT:restart_vm VM:rust FLAGS:rebuild=true nocache=true
"what'\''s running?" → INTENT:status'

    # Call the API
    local response
    response=$(call_ai_api "$user_input" "$system_prompt") || return 1

    # Extract and return the content
    local content
    content=$(extract_ai_content "$response")

    if [[ -z "$content" ]]; then
        log_error "AI returned empty response"
        return 1
    fi

    echo "$content"
    return 0
}

# Check if AI API calling is available
# Returns: 0 if API key is available, 1 otherwise
ai_api_available() {
    _get_ai_api_key >/dev/null 2>&1
}

# Show AI API configuration info
show_ai_config() {
    local base_url
    local model

    base_url=$(_get_ai_base_url)
    model=$(_get_ai_model)

    echo "AI API Configuration:"
    echo "  Base URL: $base_url"
    echo "  Model: $model"
    echo "  API Key: $(_get_ai_api_key >/dev/null 2>&1 && echo "Set (${#API_KEY}) chars" || echo "Not set")"
}
