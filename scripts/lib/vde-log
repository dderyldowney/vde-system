#!/bin/zsh
#===============================================================================
# vde-logging - Structured Logging Library for VDE
# Provides JSON/text structured logging with rotation capabilities
#===============================================================================

# Source dependencies
[[ -z "$VDE_ROOT_DIR" ]] && VDE_ROOT_DIR="${0:a:h:h}"
[[ -f "$VDE_ROOT_DIR/scripts/lib/vde-constants" ]] && source "$VDE_ROOT_DIR/scripts/lib/vde-constants"
[[ -f "$VDE_ROOT_DIR/scripts/lib/vde-shell-compat" ]] && source "$VDE_ROOT_DIR/scripts/lib/vde-shell-compat"

#===============================================================================
# Logging Configuration
#===============================================================================

# Default log settings
VDE_LOG_LEVEL="${VDE_LOG_LEVEL:-INFO}"
VDE_LOG_FORMAT="${VDE_LOG_FORMAT:-text}"
VDE_LOG_OUTPUT="${VDE_LOG_OUTPUT:-stdout}"
VDE_LOG_FILE="${VDE_ROOT_DIR}/logs/vde.log"
VDE_LOG_MAX_SIZE="${VDE_LOG_MAX_SIZE:-10485760}"  # 10MB in bytes
VDE_LOG_MAX_DAYS="${VDE_LOG_MAX_DAYS:-7}"
VDE_LOG_RETENTION_POLICY="${VDE_LOG_RETENTION_POLICY:-size}"

# Log levels (numeric values for comparison)
declare -A VDE_LOG_LEVELS=(
    ["DEBUG"]=0
    ["INFO"]=1
    ["WARN"]=2
    ["ERROR"]=3
)

# Log level names for reverse lookup
declare -a VDE_LOG_LEVEL_NAMES=("DEBUG" "INFO" "WARN" "ERROR")

# Current runtime state
_VDE_LOG_CURRENT_LEVEL=1
_VDE_LOG_INITIALIZED=0
_VDE_LOG_LAST_ROTATE_CHECK=0

#===============================================================================
# Initialization
#===============================================================================

# Initialize logging system
vde_log_init() {
    # Create logs directory if it doesn't exist
    if [[ ! -d "$VDE_ROOT_DIR/logs" ]]; then
        command mkdir -p "$VDE_ROOT_DIR/logs" 2>/dev/null || return 1
    fi
    
    # Create log file if outputting to file
    if [[ "$VDE_LOG_OUTPUT" == "file" ]] && [[ ! -f "$VDE_LOG_FILE" ]]; then
        command touch "$VDE_LOG_FILE" 2>/dev/null || return 1
        command chmod 600 "$VDE_LOG_FILE" 2>/dev/null || true
    fi
    
    # Set log level from environment or default
    vde_log_set_level "$VDE_LOG_LEVEL"
    
    # Ensure logs directory is writable
    if [[ ! -w "$VDE_ROOT_DIR/logs" ]]; then
        return 1
    fi
    
    _VDE_LOG_INITIALIZED=1
    return 0
}

#===============================================================================
# Log Level Control
#===============================================================================

# Set minimum log level
# Args: level (DEBUG|INFO|WARN|ERROR)
vde_log_set_level() {
    local level="${1:-INFO}"
    level=$(echo "$level" | tr '[:lower:]' '[:upper:]')
    
    if [[ -n "${VDE_LOG_LEVELS[$level]}" ]]; then
        _VDE_LOG_CURRENT_LEVEL="${VDE_LOG_LEVELS[$level]}"
        return 0
    fi
    return 1
}

# Get current log level name
vde_log_get_level() {
    echo "${VDE_LOG_LEVEL_NAMES[$_VDE_LOG_CURRENT_LEVEL + 1]}"
}

#===============================================================================
# Format Control
#===============================================================================

# Set output format
# Args: format (text|json|syslog)
vde_log_set_format() {
    local format="${1:-text}"
    format=$(echo "$format" | tr '[:lower:]' '[:upper:]')
    
    case "$format" in
        TEXT|JSON|SYSLOG)
            VDE_LOG_FORMAT=$(echo "$format" | tr '[:upper:]' '[:lower:]')
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

#===============================================================================
# Output Control
#===============================================================================

# Configure logging to output to file
# Args: filepath (optional, defaults to VDE_LOG_FILE)
vde_log_to_file() {
    local filepath="${1:-$VDE_LOG_FILE}"
    VDE_LOG_FILE="$filepath"
    VDE_LOG_OUTPUT="file"
    
    # Ensure directory exists
    local dir="$(dirname "$filepath")"
    if [[ ! -d "$dir" ]]; then
        command mkdir -p "$dir" 2>/dev/null || return 1
    fi
    command touch "$filepath" 2>/dev/null || return 1
    return 0
}

# Configure logging to output to stdout
vde_log_to_stdout() {
    VDE_LOG_OUTPUT="stdout"
    return 0
}

# Configure logging to output to stderr
vde_log_to_stderr() {
    VDE_LOG_OUTPUT="stderr"
    return 0
}

#===============================================================================
# Core Logging Functions
#===============================================================================

# Generic logging function
# Args: level, message, [component], [context...]
vde_log() {
    local level="$1"
    local message="$2"
    local component="${3:-vde}"
    shift 3
    local context="$@"
    
    # Validate level
    level=$(echo "$level" | tr '[:lower:]' '[:upper:]')
    if [[ -z "${VDE_LOG_LEVELS[$level]}" ]]; then
        level="INFO"
    fi
    
    # Check if we should log this level
    local level_num="${VDE_LOG_LEVELS[$level]}"
    if [[ "$level_num" -lt "$_VDE_LOG_CURRENT_LEVEL" ]]; then
        return 0
    fi
    
    # Ensure initialized
    if [[ "$_VDE_LOG_INITIALIZED" -eq 0 ]]; then
        vde_log_init || return 1
    fi
    
    # Generate timestamp (ISO 8601)
    local timestamp
    timestamp=$(vde_shell_date_iso8601)
    
    # Format based on output type
    local output
    case "$VDE_LOG_FORMAT" in
        json)
            output=$(vde_log_format_json "$timestamp" "$level" "$component" "$message" "$context")
            ;;
        syslog)
            output=$(vde_log_format_syslog "$timestamp" "$level" "$component" "$message")
            ;;
        *)
            output=$(vde_log_format_text "$timestamp" "$level" "$component" "$message")
            ;;
    esac
    
    # Check for rotation before writing
    vde_log_check_rotation
    
    # Write output
    case "$VDE_LOG_OUTPUT" in
        file)
            echo "$output" >> "$VDE_LOG_FILE"
            ;;
        stdout)
            echo "$output"
            ;;
        stderr)
            echo "$output" >&2
            ;;
    esac
    
    return 0
}

# Level-specific logging functions
vde_log_debug() {
    vde_log "DEBUG" "$@"
}

vde_log_info() {
    vde_log "INFO" "$@"
}

vde_log_warn() {
    vde_log "WARN" "$@"
}

vde_log_error() {
    vde_log "ERROR" "$@"
}

#===============================================================================
# Formatting Functions
#===============================================================================

# Format log entry as JSON
vde_log_format_json() {
    local timestamp="$1"
    local level="$2"
    local component="$3"
    local message="$4"
    local context="$5"
    
    # Escape special characters for JSON
    message=$(echo "$message" | command sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\r/\\r/g; s/\n/\\n/g')
    
    # Build JSON object
    local json="{\"timestamp\":\"$timestamp\",\"level\":\"$level\",\"component\":\"$component\",\"message\":\"$message\""
    
    if [[ -n "$context" ]]; then
        context=$(echo "$context" | command sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g; s/\r/\\r/g; s/\n/\\n/g')
        json="$json,\"context\":\"$context\""
    fi
    
    json="$json}"
    echo "$json"
}

# Format log entry as syslog-style text
vde_log_format_syslog() {
    local timestamp="$1"
    local level="$2"
    local component="$3"
    local message="$4"
    
    # Syslog format: timestamp level component: message
    echo "$timestamp $level $component: $message"
}

# Format log entry as human-readable text
vde_log_format_text() {
    local timestamp="$1"
    local level="$2"
    local component="$3"
    local message="$4"
    
    # Text format with severity indicators
    local indicator
    case "$level" in
        DEBUG) indicator="[DEBUG]" ;;
        INFO)  indicator="[INFO ]" ;;
        WARN)  indicator="[WARN ]" ;;
        ERROR) indicator="[ERROR]" ;;
        *)     indicator="[????]" ;;
    esac
    
    echo "$timestamp $indicator [$component] $message"
}

#===============================================================================
# Log Rotation
#===============================================================================

# Check if log rotation is needed
vde_log_check_rotation() {
    if [[ "$VDE_LOG_RETENTION_POLICY" != "disabled" ]]; then
        # Check based on size
        if [[ "$VDE_LOG_RETENTION_POLICY" == "size" ]] || [[ "$VDE_LOG_RETENTION_POLICY" == "both" ]]; then
            if [[ -f "$VDE_LOG_FILE" ]]; then
                local size
                size=$(command stat -f%z "$VDE_LOG_FILE" 2>/dev/null || command stat -c%s "$VDE_LOG_FILE" 2>/dev/null || echo 0)
                if [[ "$size" -ge "$VDE_LOG_MAX_SIZE" ]]; then
                    vde_log_rotate
                fi
            fi
        fi
        
        # Check based on time (daily)
        local current_date
        current_date=$(date +%Y%m%d 2>/dev/null || echo "unknown")
        if [[ "$VDE_LOG_RETENTION_POLICY" == "time" ]] || [[ "$VDE_LOG_RETENTION_POLICY" == "both" ]]; then
            if [[ "$current_date" != "$_VDE_LOG_LAST_ROTATE_CHECK" ]]; then
                vde_log_rotate
                _VDE_LOG_LAST_ROTATE_CHECK="$current_date"
            fi
        fi
    fi
}

# Perform log rotation
vde_log_rotate() {
    if [[ ! -f "$VDE_LOG_FILE" ]]; then
        return 0
    fi
    
    # Ensure logs directory exists
    local log_dir="$(dirname "$VDE_LOG_FILE")"
    [[ ! -d "$log_dir" ]] && command mkdir -p "$log_dir" 2>/dev/null || return 1
    
    # Generate timestamp for rotated file
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S 2>/dev/null || echo "unknown")
    
    # Compress current log
    local rotated_file="${VDE_LOG_FILE}.${timestamp}.gz"
    
    # Check if gzip is available
    if command -v gzip >/dev/null 2>&1; then
        command gzip -c "$VDE_LOG_FILE" > "$rotated_file" 2>/dev/null || {
            # Fallback: just rename if gzip fails
            command mv "$VDE_LOG_FILE" "${VDE_LOG_FILE}.${timestamp}" 2>/dev/null
        }
    else
        command mv "$VDE_LOG_FILE" "${VDE_LOG_FILE}.${timestamp}" 2>/dev/null
    fi
    
    # Create new log file
    command touch "$VDE_LOG_FILE" 2>/dev/null || return 1
    command chmod 600 "$VDE_LOG_FILE" 2>/dev/null || true
    
    # Clean up old logs
    vde_log_cleanup
    
    return 0
}

# Clean up old log files
vde_log_cleanup() {
    local log_dir="$(dirname "$VDE_LOG_FILE")"
    
    if [[ ! -d "$log_dir" ]]; then
        return 0
    fi
    
    local base_name="$(basename "$VDE_LOG_FILE")"
    
    # Find and remove files older than retention period
    if command -v find >/dev/null 2>&1; then
        # Calculate cutoff date
        local cutoff_date
        cutoff_date=$(date -d "$VDE_LOG_MAX_DAYS days ago" +%Y%m%d 2>/dev/null || date -v-"${VDE_LOG_MAX_DAYS}d" +%Y%m%d 2>/dev/null || echo "19700101")
        
        # Remove old rotated log files
        command find "$log_dir" -name "${base_name}.*.gz" -mtime +"$VDE_LOG_MAX_DAYS" -delete 2>/dev/null || true
        command find "$log_dir" -name "${base_name}.*" ! -name "$base_name" -mtime +"$VDE_LOG_MAX_DAYS" -delete 2>/dev/null || true
    fi
    
    return 0
}

#===============================================================================
# Log Query Functions
#===============================================================================

# Get recent log entries
# Args: [count]
vde_log_recent() {
    local count="${1:-50}"
    
    if [[ -f "$VDE_LOG_FILE" ]]; then
        command tail -n "$count" "$VDE_LOG_FILE"
    fi
}

# Search logs
# Args: pattern
vde_log_grep() {
    local pattern="$1"
    shift
    
    if [[ -f "$VDE_LOG_FILE" ]]; then
        command grep -E "$pattern" "$VDE_LOG_FILE" "$@"
    fi
}

# Get error logs
vde_log_errors() {
    local count="${1:-100}"
    
    if [[ -f "$VDE_LOG_FILE" ]]; then
        command grep -E "\[ERROR\]" "$VDE_LOG_FILE" | command tail -n "$count"
    fi
}

#===============================================================================
# Convenience Functions
#===============================================================================

# Log function entry (for debugging)
vde_log_function() {
    local func_name="${FUNCNAME[1]:-unknown}"
    vde_log_debug "Entering function: $func_name" "core"
}

# Log function exit (for debugging)
vde_log_function_return() {
    local func_name="${FUNCNAME[1]:-unknown}"
    local exit_code="$?"
    if [[ "$exit_code" -eq 0 ]]; then
        vde_log_debug "Exiting function: $func_name (success)" "core"
    else
        vde_log_debug "Exiting function: $func_name (exit code: $exit_code)" "core"
    fi
}

# Export logs to JSON format
vde_log_export() {
    local output_file="${1:-${VDE_ROOT_DIR}/logs/vde-exported.json}"
    
    if [[ -f "$VDE_LOG_FILE" ]]; then
        vde_log_set_format json
        command cp "$VDE_LOG_FILE" "$output_file"
        vde_log_set_format text
        return 0
    fi
    return 1
}

#===============================================================================
# Backward Compatibility
#===============================================================================

# Legacy log function (maps to vde_log_info)
_vde_log() {
    vde_log_info "$@"
}

# Export functions for backward compatibility
export -f vde_log_init >/dev/null 2>&1 || true
export -f vde_log >/dev/null 2>&1 || true
export -f vde_log_debug >/dev/null 2>&1 || true
export -f vde_log_info >/dev/null 2>&1 || true
export -f vde_log_warn >/dev/null 2>&1 || true
export -f vde_log_error >/dev/null 2>&1 || true
export -f vde_log_set_level >/dev/null 2>&1 || true
export -f vde_log_set_format >/dev/null 2>&1 || true
export -f vde_log_to_file >/dev/null 2>&1 || true
export -f vde_log_to_stdout >/dev/null 2>&1 || true
export -f vde_log_rotate >/dev/null 2>&1 || true
export -f vde_log_check_rotation >/dev/null 2>&1 || true
export -f vde_log_cleanup >/dev/null 2>&1 || true
