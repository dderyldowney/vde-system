#!/bin/zsh
# VDE Commands Library
# Wrapper functions for all VDE operations
# Source this library with: source ./scripts/lib/vde-commands
#
# This library provides high-level command wrappers for VDE operations.
# All functions log their actions and provide consistent error handling.
#
# Shell Compatibility (Stage 4):
# - Uses POSIX-compatible syntax
# - Supports zsh 5.0+, bash 4.0+, bash 3.x
#
# Return Codes: All functions use standardized return codes from vde-constants:
#   VDE_SUCCESS (0)        - Operation completed successfully
#   VDE_ERR_GENERAL (1)    - Unspecified failure
#   VDE_ERR_INVALID_INPUT (2) - Bad arguments or validation failure
#   VDE_ERR_NOT_FOUND (3)  - Resource doesn't exist
#   VDE_ERR_DOCKER (8)     - Docker operation failure

# -----------------------
# Source Guard
# -----------------------
# Prevent multiple sourcing which causes readonly variable errors
if [ "${_VDE_COMMANDS_LOADED:-}" = "1" ]; then
    return 0 2>/dev/null || exit 0
fi
_VDE_COMMANDS_LOADED=1

# -----------------------
# Dependencies
# -----------------------
# This library requires vm-common to be sourced first
# The caller should have already: source "$SCRIPT_DIR/lib/vm-common"
# vm-common provides: VDE_SUCCESS, VDE_ERR_*, log_*, VM operations, etc.

# -----------------------
# Configuration
# -----------------------
VDE_COMMANDS_LOG="${VDE_ROOT_DIR}/logs/vde-commands.log"
VDE_SCRIPTS_DIR="${VDE_ROOT_DIR}/scripts"

# ensure_commands_log_dir - Ensure the commands log directory exists
# Args: none
# Returns: VDE_SUCCESS (0)
# Example: ensure_commands_log_dir
ensure_commands_log_dir() {
    mkdir -p "$(dirname "$VDE_COMMANDS_LOG")"
    return $VDE_SUCCESS
}

# log_command_action - Log a VDE command action to the log file
# Args:
#   action - The action being performed (e.g., "start_vm", "create_vm")
#   details - Additional details about the action
# Returns: VDE_SUCCESS (0)
# Example: log_command_action "start_vm" "python (rebuild=true)"
log_command_action() {
    local action="$1"
    local details="$2"
    ensure_commands_log_dir
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $action: $details" >> "$VDE_COMMANDS_LOG"
    return $VDE_SUCCESS
}

# -----------------------
# Query Functions
# -----------------------

# vde_list_vms - List VMs with optional filtering
# Args:
#   filter - Optional filter: --lang (language VMs), --svc (service VMs), --all (default)
# Returns: VDE_SUCCESS (0), outputs list of VM names to stdout
# Example: vde_list_vms --lang
vde_list_vms() {
    local filter="${1:-all}"

    case "$filter" in
        --lang)
            get_lang_vms
            ;;
        --svc)
            get_service_vms
            ;;
        --all|*)
            get_all_vms
            ;;
    esac
    return $VDE_SUCCESS
}

# vde_vm_exists - Check if VM exists (has docker-compose.yml)
# Args:
#   vm_name - Name of the VM to check
# Returns: VDE_SUCCESS (0) if exists, VDE_ERR_NOT_FOUND (3) if not
# Example: vde_vm_exists python && echo "Python VM exists"
vde_vm_exists() {
    local vm_name="$1"
    vm_exists "$vm_name"
}

# vde_get_vm_info - Get VM information from configuration
# Args:
#   vm_name - Name of the VM
#   field - Optional field to retrieve: type|aliases|display|install|svc_port (default: type)
# Returns: VDE_SUCCESS (0), outputs field value to stdout
# Example: vde_get_vm_info python type
vde_get_vm_info() {
    local vm_name="$1"
    local field="${2:-type}"

    get_vm_info "$field" "$vm_name"
}

# vde_get_running_vms - Get list of running VMs
# Args: none
# Returns: VDE_SUCCESS (0), outputs list of running container names to stdout
# Example: running=$(vde_get_running_vms)
vde_get_running_vms() {
    docker ps --format "{{.Names}}" 2>/dev/null | grep -E "^[a-z0-9]+-dev$|^[a-z0-9]+$" || echo ""
    return $VDE_SUCCESS
}

# vde_get_vm_status - Get status of a specific VM
# Args:
#   vm_name - Name of the VM to check
# Returns: VDE_SUCCESS (0), outputs status string to stdout
#   Status values: "running", "stopped", "not_created", or "unknown"
# Example: status=$(vde_get_vm_status python)
vde_get_vm_status() {
    local vm_name="$1"
    local container_name

    # Determine container name based on VM type
    local vm_type
    vm_type=$(get_vm_info type "$vm_name" 2>/dev/null || echo "")

    if [ "$vm_type" = "lang" ]; then
        container_name="${vm_name}-dev"
    else
        container_name="$vm_name"
    fi

    # Check container status
    local container_status
    container_status=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}" 2>/dev/null | head -1)

    if [ -z "$container_status" ]; then
        echo "not_created"
    else
        case "$container_status" in
            *Up*)
                echo "running"
                ;;
            *Exited*)
                echo "stopped"
                ;;
            *)
                echo "unknown"
                ;;
        esac
    fi
    return $VDE_SUCCESS
}

# vde_get_ssh_info - Get SSH connection info for a VM
# Args:
#   vm_name - Name of the VM
# Returns: VDE_SUCCESS (0) with "host|port" on stdout, VDE_ERR_NOT_FOUND (3) if no SSH info
# Example: ssh_info=$(vde_get_ssh_info python)
vde_get_ssh_info() {
    local vm_name="$1"
    local ssh_host
    local ssh_port

    # Determine SSH host based on VM type
    local vm_type
    vm_type=$(get_vm_info type "$vm_name" 2>/dev/null || echo "")

    if [ "$vm_type" = "lang" ]; then
        ssh_host="${vm_name}-dev"
    else
        ssh_host="$vm_name"
    fi

    # Get SSH port from docker-compose.yml
    ssh_port=$(get_vm_ssh_port "$vm_name" 2>/dev/null || echo "")

    if [ -z "$ssh_port" ]; then
        echo ""
        return $VDE_ERR_NOT_FOUND
    fi

    echo "$ssh_host|$ssh_port"
    return $VDE_SUCCESS
}

# vde_resolve_alias - Resolve alias to canonical VM name
# Args:
#   input - Name or alias to resolve
# Returns: VDE_SUCCESS (0), outputs canonical name to stdout
# Example: canonical=$(vde_resolve_alias py)  # Returns "python"
vde_resolve_alias() {
    local input="$1"
    resolve_vm_name "$input"
}

# vde_validate_vm_type - Validate if a name is a known VM type
# Args:
#   name - Name to validate
# Returns: VDE_SUCCESS (0) if known, VDE_ERR_NOT_FOUND (3) if not
# Example: vde_validate_vm_type python && echo "Valid VM type"
vde_validate_vm_type() {
    local name="$1"
    is_known_vm "$name"
}

# -----------------------
# Action Functions
# -----------------------

# vde_create_vm - Create a new VM
# Args:
#   vm_name - Name of the VM to create
#   force - Optional: pass "--force" to overwrite existing VM
# Returns: Exit code from create-virtual-for script
#   VDE_SUCCESS (0) on success, VDE_ERR_GENERAL (1) on failure
# Example: vde_create_vm python --force
vde_create_vm() {
    local vm_name="$1"
    local force="${2:-}"

    log_command_action "create_vm" "$vm_name"

    if [ -n "$force" ]; then
        "$VDE_SCRIPTS_DIR/create-virtual-for" "$vm_name" --force
    else
        "$VDE_SCRIPTS_DIR/create-virtual-for" "$vm_name"
    fi
}

# vde_start_vm - Start a VM
# Args:
#   vm_name - Name of the VM to start
#   rebuild - Optional: "true" to rebuild the container (default: "false")
#   nocache - Optional: "true" to build without cache (default: "false")
# Returns: Exit code from start-virtual script
#   VDE_SUCCESS (0) on success, VDE_ERR_DOCKER (8) on failure
# Example: vde_start_vm python true false
vde_start_vm() {
    local vm_name="$1"
    local rebuild="${2:-false}"
    local nocache="${3:-false}"

    log_command_action "start_vm" "$vm_name (rebuild=$rebuild, nocache=$nocache)"

    set -- "$vm_name"
    [ "$rebuild" = "true" ] && set -- "$@" --rebuild
    [ "$nocache" = "true" ] && set -- "$@" --no-cache

    "$VDE_SCRIPTS_DIR/start-virtual" "$@"
}

# vde_stop_vm - Stop a VM
# Args:
#   vm_name - Name of the VM to stop
# Returns: Exit code from shutdown-virtual script
#   VDE_SUCCESS (0) on success, VDE_ERR_DOCKER (8) on failure
# Example: vde_stop_vm python
vde_stop_vm() {
    local vm_name="$1"

    log_command_action "stop_vm" "$vm_name"

    "$VDE_SCRIPTS_DIR/shutdown-virtual" "$vm_name"
}

# vde_restart_vm - Restart a VM (stop then start)
# Args:
#   vm_name - Name of the VM to restart
#   rebuild - Optional: "true" to rebuild the container (default: "false")
#   nocache - Optional: "true" to build without cache (default: "false")
# Returns: Exit code from start operation
#   VDE_SUCCESS (0) on success, VDE_ERR_DOCKER (8) on failure
# Example: vde_restart_vm python true false
vde_restart_vm() {
    local vm_name="$1"
    local rebuild="${2:-false}"
    local nocache="${3:-false}"

    log_command_action "restart_vm" "$vm_name (rebuild=$rebuild, nocache=$nocache)"

    # Stop first
    vde_stop_vm "$vm_name"

    # Then start with requested flags
    vde_start_vm "$vm_name" "$rebuild" "$nocache"
}

# vde_start_all - Start all VMs
# Args:
#   rebuild - Optional: "true" to rebuild containers (default: "false")
#   nocache - Optional: "true" to build without cache (default: "false")
# Returns: Exit code from start-virtual script
#   VDE_SUCCESS (0) on success, VDE_ERR_DOCKER (8) on failure
# Example: vde_start_all true false
vde_start_all() {
    local rebuild="${1:-false}"
    local nocache="${2:-false}"

    log_command_action "start_all" "rebuild=$rebuild, nocache=$nocache"

    set -- all
    [ "$rebuild" = "true" ] && set -- "$@" --rebuild
    [ "$nocache" = "true" ] && set -- "$@" --no-cache

    "$VDE_SCRIPTS_DIR/start-virtual" "$@"
}

# vde_stop_all - Stop all VMs
# Args: none
# Returns: Exit code from shutdown-virtual script
#   VDE_SUCCESS (0) on success, VDE_ERR_DOCKER (8) on failure
# Example: vde_stop_all
vde_stop_all() {
    log_command_action "stop_all" ""

    "$VDE_SCRIPTS_DIR/shutdown-virtual" all
}

# vde_add_vm_type - Add a new VM type to the configuration
# Args:
#   name - Name of the new VM type
#   install_cmd - Installation command for the VM
#   aliases - Optional: space-separated list of aliases
#   --type TYPE - Optional: VM type (lang or svc)
#   --svc-port PORT - Optional: service port for svc type VMs
#   --display NAME - Optional: display name for the VM
# Returns: Exit code from add-vm-type script
#   VDE_SUCCESS (0) on success, VDE_ERR_GENERAL (1) on failure
# Example: vde_add_vm_type golang "apt install golang" "go" --type lang --display "Go"
vde_add_vm_type() {
    local name="$1"
    local install_cmd="$2"
    local aliases="${3:-}"
    shift 3  # Remove first 3 args

    # Parse remaining options
    local type_str=""
    local svc_port=""
    local display=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --type)
                type_str="$2"
                shift 2
                ;;
            --svc-port)
                svc_port="$2"
                shift 2
                ;;
            --display)
                display="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    log_command_action "add_vm_type" "$name"

    # Build command args using positional parameters
    set --
    [ -n "$type_str" ] && set -- "$@" --type "$type_str"
    [ -n "$svc_port" ] && set -- "$@" --svc-port "$svc_port"
    [ -n "$display" ] && set -- "$@" --display "$display"
    set -- "$@" "$name" "$install_cmd"
    # Note: $aliases is intentionally unquoted here as it contains space-separated aliases
    # that add-vm-type will treat as a single argument
    [ -n "$aliases" ] && set -- "$@" "$aliases"

    "$VDE_SCRIPTS_DIR/add-vm-type" "$@"
}

# -----------------------
# Batch Operations
# -----------------------

# vde_create_multiple_vms - Create multiple VMs in sequence
# Args:
#   vm_name1, vm_name2, ... - Names of VMs to create
# Returns: VDE_SUCCESS (0), outputs "CREATED:" and "FAILED:" lists to stdout
# Example: vde_create_multiple_vms python rust golang
vde_create_multiple_vms() {
    local created=""
    local failed=""

    local vm
    for vm in "$@"; do
        if vde_create_vm "$vm"; then
            if [ -n "$created" ]; then
                created="$created $vm"
            else
                created="$vm"
            fi
        else
            if [ -n "$failed" ]; then
                failed="$failed $vm"
            else
                failed="$vm"
            fi
        fi
    done

    # Return results
    echo "CREATED: $created"
    echo "FAILED: $failed"
    return $VDE_SUCCESS
}

# vde_start_multiple_vms - Start multiple VMs in sequence
# Args:
#   --rebuild - Optional: rebuild containers before starting
#   --no-cache - Optional: build without cache
#   vm_name1, vm_name2, ... - Names of VMs to start
# Returns: VDE_SUCCESS (0), outputs "STARTED:" and "FAILED:" lists to stdout
# Example: vde_start_multiple_vms --rebuild python rust
vde_start_multiple_vms() {
    local rebuild="false"
    local nocache="false"
    local vms=""

    # Parse flags
    while [ $# -gt 0 ]; do
        case "$1" in
            --rebuild)
                rebuild="true"
                shift
                ;;
            --no-cache)
                nocache="true"
                shift
                ;;
            *)
                if [ -n "$vms" ]; then
                    vms="$vms $1"
                else
                    vms="$1"
                fi
                shift
                ;;
        esac
    done

    local started=""
    local failed=""

    local vm
    for vm in $vms; do
        if vde_start_vm "$vm" "$rebuild" "$nocache"; then
            if [ -n "$started" ]; then
                started="$started $vm"
            else
                started="$vm"
            fi
        else
            if [ -n "$failed" ]; then
                failed="$failed $vm"
            else
                failed="$vm"
            fi
        fi
    done

    # Return results
    echo "STARTED: $started"
    echo "FAILED: $failed"
    return $VDE_SUCCESS
}

# vde_stop_multiple_vms - Stop multiple VMs in sequence
# Args:
#   vm_name1, vm_name2, ... - Names of VMs to stop
# Returns: VDE_SUCCESS (0), outputs "STOPPED:" and "FAILED:" lists to stdout
# Example: vde_stop_multiple_vms python rust golang
vde_stop_multiple_vms() {
    local stopped=""
    local failed=""

    local vm
    for vm in "$@"; do
        if vde_stop_vm "$vm"; then
            if [ -n "$stopped" ]; then
                stopped="$stopped $vm"
            else
                stopped="$vm"
            fi
        else
            if [ -n "$failed" ]; then
                failed="$failed $vm"
            else
                failed="$vm"
            fi
        fi
    done

    # Return results
    echo "STOPPED: $stopped"
    echo "FAILED: $failed"
    return $VDE_SUCCESS
}

# -----------------------
# Dry Run Mode
# -----------------------
VDE_DRY_RUN=false

# vde_set_dry_run - Enable or disable dry run mode
# Args:
#   enabled - "true" to enable dry run, "false" to disable
# Returns: VDE_SUCCESS (0)
# Example: vde_set_dry_run true
vde_set_dry_run() {
    VDE_DRY_RUN="$1"
    return $VDE_SUCCESS
}

# vde_exec - Execute command with dry run support
# When dry run is enabled, prints what would be executed instead of running
# Args:
#   command args... - Command and arguments to execute
# Returns: VDE_SUCCESS (0) in dry run mode, otherwise exit code from command
# Example: vde_exec docker-compose up -d
vde_exec() {
    if [ "$VDE_DRY_RUN" = "true" ]; then
        echo "[DRY RUN] Would execute: $*"
        return $VDE_SUCCESS
    else
        "$@"
    fi
}
