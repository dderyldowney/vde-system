#!/usr/bin/env zsh
# VDE Commands Library
# Wrapper functions for all VDE operations that the AI assistant can call
# Source this library with: source ./scripts/lib/vde-commands

# -----------------------
# Dependencies
# -----------------------
# This library requires vm-common to be sourced first
# The caller should have already: source "$SCRIPT_DIR/lib/vm-common"

# -----------------------
# Configuration
# -----------------------
VDE_AI_LOG="${VDE_ROOT_DIR}/logs/vde-ai.log"
VDE_SCRIPTS_DIR="${VDE_ROOT_DIR}/scripts"

# Ensure logs directory exists
ensure_ai_log_dir() {
    mkdir -p "$(dirname "$VDE_AI_LOG")"
}

# Log AI actions
log_ai_action() {
    local action="$1"
    local details="$2"
    ensure_ai_log_dir
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $action: $details" >> "$VDE_AI_LOG"
}

# -----------------------
# Query Functions
# -----------------------

# List VMs with optional filtering
# Args: [--lang|--svc|--all]
vde_list_vms() {
    local filter="${1:-all}"

    case "$filter" in
        --lang)
            get_lang_vms
            ;;
        --svc)
            get_service_vms
            ;;
        --all|*)
            get_all_vms
            ;;
    esac
}

# Check if VM exists (has docker-compose.yml)
# Args: <vm_name>
# Returns: 0 if exists, 1 if not
vde_vm_exists() {
    local vm_name="$1"
    vm_exists "$vm_name"
}

# Get VM information
# Args: <vm_name> [field]
# Fields: type|aliases|display|install|svc_port
vde_get_vm_info() {
    local vm_name="$1"
    local field="${2:-type}"

    get_vm_info "$field" "$vm_name"
}

# Get list of running VMs
# Returns: List of currently running container names
vde_get_running_vms() {
    docker ps --format "{{.Names}}" 2>/dev/null | grep -E "^[a-z]+-dev$|^[a-z]+$" || echo ""
}

# Get status of a specific VM
# Args: <vm_name>
# Returns: "running", "stopped", "not_created", or "unknown"
vde_get_vm_status() {
    local vm_name="$1"
    local container_name

    # Determine container name based on VM type
    local vm_type
    vm_type=$(get_vm_info type "$vm_name" 2>/dev/null || echo "")

    if [[ "$vm_type" == "lang" ]]; then
        container_name="${vm_name}-dev"
    else
        container_name="$vm_name"
    fi

    # Check container status
    local container_status
    container_status=$(docker ps -a --filter "name=${container_name}" --format "{{.Status}}" 2>/dev/null | head -1)

    if [[ -z "$container_status" ]]; then
        echo "not_created"
    elif [[ "$container_status" =~ "Up" ]]; then
        echo "running"
    elif [[ "$container_status" =~ "Exited" ]]; then
        echo "stopped"
    else
        echo "unknown"
    fi
}

# Get SSH connection info for a VM
# Args: <vm_name>
# Returns: SSH host and port info
vde_get_ssh_info() {
    local vm_name="$1"
    local ssh_host
    local ssh_port

    # Determine SSH host based on VM type
    local vm_type
    vm_type=$(get_vm_info type "$vm_name" 2>/dev/null || echo "")

    if [[ "$vm_type" == "lang" ]]; then
        ssh_host="${vm_name}-dev"
    else
        ssh_host="$vm_name"
    fi

    # Get SSH port from docker-compose.yml
    ssh_port=$(get_vm_ssh_port "$vm_name" 2>/dev/null || echo "")

    if [[ -z "$ssh_port" ]]; then
        echo ""
        return 1
    fi

    echo "$ssh_host|$ssh_port"
}

# Resolve alias to canonical VM name
# Args: <name_or_alias>
vde_resolve_alias() {
    local input="$1"
    resolve_vm_name "$input"
}

# Validate if a name is a known VM type
# Args: <name>
vde_validate_vm_type() {
    local name="$1"
    is_known_vm "$name"
}

# -----------------------
# Action Functions
# -----------------------

# Create a new VM
# Args: <vm_name> [--force]
vde_create_vm() {
    local vm_name="$1"
    local force="${2:-}"

    log_ai_action "create_vm" "$vm_name"

    if [[ -n "$force" ]]; then
        "$VDE_SCRIPTS_DIR/create-virtual-for" "$vm_name" --force
    else
        "$VDE_SCRIPTS_DIR/create-virtual-for" "$vm_name"
    fi
}

# Start a VM
# Args: <vm_name> [--rebuild] [--no-cache]
vde_start_vm() {
    local vm_name="$1"
    local rebuild="${2:-false}"
    local nocache="${3:-false}"

    log_ai_action "start_vm" "$vm_name (rebuild=$rebuild, nocache=$nocache)"

    local args=("$vm_name")
    [[ "$rebuild" == "true" ]] && args+=(--rebuild)
    [[ "$nocache" == "true" ]] && args+=(--no-cache)

    "$VDE_SCRIPTS_DIR/start-virtual" "${args[@]}"
}

# Stop a VM
# Args: <vm_name>
vde_stop_vm() {
    local vm_name="$1"

    log_ai_action "stop_vm" "$vm_name"

    "$VDE_SCRIPTS_DIR/shutdown-virtual" "$vm_name"
}

# Restart a VM
# Args: <vm_name> [--rebuild] [--no-cache]
vde_restart_vm() {
    local vm_name="$1"
    local rebuild="${2:-false}"
    local nocache="${3:-false}"

    log_ai_action "restart_vm" "$vm_name (rebuild=$rebuild, nocache=$nocache)"

    # Stop first
    vde_stop_vm "$vm_name"

    # Then start with requested flags
    vde_start_vm "$vm_name" "$rebuild" "$nocache"
}

# Start all VMs
# Args: [--rebuild] [--no-cache]
vde_start_all() {
    local rebuild="${1:-false}"
    local nocache="${2:-false}"

    log_ai_action "start_all" "rebuild=$rebuild, nocache=$nocache"

    local args=(all)
    [[ "$rebuild" == "true" ]] && args+=(--rebuild)
    [[ "$nocache" == "true" ]] && args+=(--no-cache)

    "$VDE_SCRIPTS_DIR/start-virtual" "${args[@]}"
}

# Stop all VMs
vde_stop_all() {
    log_ai_action "stop_all" ""

    "$VDE_SCRIPTS_DIR/shutdown-virtual" all
}

# Add a new VM type
# Args: <name> "<install_cmd>" [aliases] [--type TYPE] [--svc-port PORT] [--display NAME]
vde_add_vm_type() {
    local name="$1"
    local install_cmd="$2"
    local aliases="${3:-}"
    shift 3  # Remove first 3 args

    # Parse remaining options
    local type_str=""
    local svc_port=""
    local display=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --type)
                type_str="$2"
                shift 2
                ;;
            --svc-port)
                svc_port="$2"
                shift 2
                ;;
            --display)
                display="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    log_ai_action "add_vm_type" "$name"

    # Build command args
    local cmd_args=()
    [[ -n "$type_str" ]] && cmd_args+=(--type "$type_str")
    [[ -n "$svc_port" ]] && cmd_args+=(--svc-port "$svc_port")
    [[ -n "$display" ]] && cmd_args+=(--display "$display")
    cmd_args+=("$name" "$install_cmd")
    [[ -n "$aliases" ]] && cmd_args+=("$aliases")

    "$VDE_SCRIPTS_DIR/add-vm-type" "${cmd_args[@]}"
}

# -----------------------
# Batch Operations
# -----------------------

# Create multiple VMs
# Args: <vm_name1> <vm_name2> ...
vde_create_multiple_vms() {
    local vms=("$@")
    local created=()
    local failed=()

    for vm in "${vms[@]}"; do
        if vde_create_vm "$vm"; then
            created+=("$vm")
        else
            failed+=("$vm")
        fi
    done

    # Return results
    echo "CREATED: ${created[*]}"
    echo "FAILED: ${failed[*]}"
}

# Start multiple VMs
# Args: [--rebuild] [--no-cache] <vm_name1> <vm_name2> ...
vde_start_multiple_vms() {
    local rebuild="false"
    local nocache="false"
    local vms=()

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --rebuild)
                rebuild="true"
                shift
                ;;
            --no-cache)
                nocache="true"
                shift
                ;;
            *)
                vms+=("$1")
                shift
                ;;
        esac
    done

    local started=()
    local failed=()

    for vm in "${vms[@]}"; do
        if vde_start_vm "$vm" "$rebuild" "$nocache"; then
            started+=("$vm")
        else
            failed+=("$vm")
        fi
    done

    # Return results
    echo "STARTED: ${started[*]}"
    echo "FAILED: ${failed[*]}"
}

# Stop multiple VMs
# Args: <vm_name1> <vm_name2> ...
vde_stop_multiple_vms() {
    local vms=("$@")
    local stopped=()
    local failed=()

    for vm in "${vms[@]}"; do
        if vde_stop_vm "$vm"; then
            stopped+=("$vm")
        else
            failed+=("$vm")
        fi
    done

    # Return results
    echo "STOPPED: ${stopped[*]}"
    echo "FAILED: ${failed[*]}"
}

# -----------------------
# Dry Run Mode
# -----------------------
VDE_DRY_RUN=false

# Enable/disable dry run mode
vde_set_dry_run() {
    VDE_DRY_RUN="$1"
}

# Execute command with dry run support
vde_exec() {
    if [[ "$VDE_DRY_RUN" == "true" ]]; then
        echo "[DRY RUN] Would execute: $*"
        return 0
    else
        "$@"
    fi
}
