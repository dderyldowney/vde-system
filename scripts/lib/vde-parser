#!/bin/zsh
# VDE Natural Language Parser
# Parses natural language input into structured VDE commands
# Source this library with: source ./scripts/lib/vde-parser
#
# This library provides natural language parsing for VDE commands, enabling
# users to interact with VDE using conversational commands like:
#   "start the python VM"
#   "what VMs are running?"
#   "create a new rust container"
#
# Shell Compatibility (Stage 4):
# - Uses vde-shell-compat for portable operations
# - Supports zsh 5.0+, bash 4.0+, bash 3.x (with fallbacks)
#
# Return Codes: All functions use standardized return codes from vde-constants:
#   VDE_SUCCESS (0)        - Operation completed successfully
#   VDE_ERR_GENERAL (1)    - Unspecified failure
#   VDE_ERR_INVALID_INPUT (2) - Bad arguments or validation failure
#   VDE_ERR_NOT_FOUND (3)  - Resource doesn't exist

# -----------------------
# Source Guard
# -----------------------
# Prevent multiple sourcing which causes readonly variable errors
if [ "${_VDE_PARSER_LOADED:-}" = "1" ]; then
    return 0 2>/dev/null || exit 0
fi
_VDE_PARSER_LOADED=1

# -----------------------
# Dependencies
# -----------------------
# This library requires vm-common and vde-commands to be sourced first
# vm-common provides: VDE_SUCCESS, VDE_ERR_*, log_*, get_all_vms, etc.

# -----------------------
# VM Alias Map (Performance Optimization)
# -----------------------
# Pre-built alias-to-name mapping for O(1) lookup instead of O(n×m) nested loops
_assoc_init "VM_ALIAS_MAP"
_VM_ALIAS_MAP_BUILT=0

# _build_alias_map - Build the alias-to-name mapping for fast lookup
# This function pre-computes a hash map where each alias points to its canonical VM name
# Args: none
# Returns: VDE_SUCCESS (0)
# Side Effects: Populates VM_ALIAS_MAP associative array
# Example: _build_alias_map && echo "Map built"
_build_alias_map() {
    # Clear existing map
    _assoc_clear "VM_ALIAS_MAP"

    # Get all VMs - convert space-separated to newline-separated for while read
    local all_vms
    all_vms=$(get_all_vms 2>/dev/null)

    # Declare variables outside loop to avoid zsh subshell scoping issues
    local alias_list
    local alias_item

    # Convert spaces to newlines and iterate
    echo "$all_vms" | tr ' ' '\n' | while IFS= read -r vm; do
        [ -n "$vm" ] || continue
        # Map the canonical name to itself
        _assoc_set "VM_ALIAS_MAP" "$vm" "$vm"

        # Get aliases for this VM
        alias_list=$(get_vm_info aliases "$vm" 2>/dev/null)

        if [ -n "$alias_list" ]; then
            # Split aliases by comma and add each to the map
            echo "$alias_list" | tr ',' '\n' | while IFS= read -r alias_item; do
                # Trim whitespace
                alias_item=$(echo "$alias_item" | tr -d ' ')
                if [ -n "$alias_item" ]; then
                    _assoc_set "VM_ALIAS_MAP" "$alias_item" "$vm"
                fi
            done
        fi
    done

    _VM_ALIAS_MAP_BUILT=1
    return $VDE_SUCCESS
}

# _ensure_alias_map - Ensure the alias map is built (lazy initialization)
# Args: none
# Returns: VDE_SUCCESS (0)
_ensure_alias_map() {
    if [ $_VM_ALIAS_MAP_BUILT -eq 0 ]; then
        _build_alias_map
    fi
    return $VDE_SUCCESS
}

# _lookup_vm_by_alias - O(1) lookup of VM name by alias
# Args: <alias_or_name> - The alias or canonical name to look up
# Returns:
#   VDE_SUCCESS (0) - Found, outputs canonical VM name to stdout
#   VDE_ERR_NOT_FOUND (3) - No matching VM found
# Example: vm=$(_lookup_vm_by_alias "py")  # outputs "python"
_lookup_vm_by_alias() {
    local input="$1"
    
    # Ensure map is built
    _ensure_alias_map
    
    # Direct O(1) lookup
    local canonical
    canonical=$(_assoc_get "VM_ALIAS_MAP" "$input" 2>/dev/null)
    
    if [ -n "$canonical" ]; then
        echo "$canonical"
        return $VDE_SUCCESS
    fi
    
    return $VDE_ERR_NOT_FOUND
}

# invalidate_alias_map - Force rebuild of alias map
# Call this when VM types are modified
# Args: none
# Returns: VDE_SUCCESS (0)
invalidate_alias_map() {
    _VM_ALIAS_MAP_BUILT=0
    _assoc_clear "VM_ALIAS_MAP"
    return $VDE_SUCCESS
}

# -----------------------
# Intent Constants
# -----------------------
# These constants define the recognized user intents for command parsing
INTENT_LIST_VMS="list_vms"
readonly INTENT_LIST_VMS
INTENT_CREATE_VM="create_vm"
readonly INTENT_CREATE_VM
INTENT_START_VM="start_vm"
readonly INTENT_START_VM
INTENT_STOP_VM="stop_vm"
readonly INTENT_STOP_VM
INTENT_RESTART_VM="restart_vm"
readonly INTENT_RESTART_VM
INTENT_STATUS="status"
readonly INTENT_STATUS
INTENT_CONNECT="connect"
readonly INTENT_CONNECT
INTENT_ADD_VM_TYPE="add_vm_type"
readonly INTENT_ADD_VM_TYPE
INTENT_HELP="help"
readonly INTENT_HELP

# -----------------------
# Intent Detection
# -----------------------

# detect_intent - Detect the primary intent from user input
# Analyzes natural language input to determine what action the user wants
# Args: <input_string> - The user's natural language input
# Returns:
#   VDE_SUCCESS (0) - Always succeeds, outputs intent constant to stdout
# Output: One of the INTENT_* constants (e.g., INTENT_START_VM)
# Example: intent=$(detect_intent "start the python VM")  # outputs "start_vm"
detect_intent() {
    local input="$1"
    local input_lower
    input_lower=$(echo "$input" | tr '[:upper:]' '[:lower:]')

    # Check for help intent first (includes common typos: hel, hepl)
    case "$input_lower" in
        *help*|*hel*|*hepl*|*"what can i do"*|*"how do i use"*)
            echo "$INTENT_HELP"
            return $VDE_SUCCESS
            ;;
    esac

    # Check for status BEFORE list/show (specific patterns)
    # Includes typo patterns: staus, satus (vowel swap), runing, runnig (omission)
    case "$input_lower" in
        *"show status"*|*"show status of"*|*"status of"*|*staus*|*satus*)
            echo "$INTENT_STATUS"
            return $VDE_SUCCESS
            ;;
    esac

    # Check for list/show intents (general patterns)
    # Includes typo patterns: lis, lst (prefix omission), shw (omission)
    case "$input_lower" in
        *list*|*lis*|*lst*|*show*|*shw*|*"what available"*|*what*available*)
            echo "$INTENT_LIST_VMS"
            return $VDE_SUCCESS
            ;;
    esac

    # Check for "what can I create" or similar patterns
    case "$input_lower" in
        *"what can i"*|*"what vms"*|*"which vms"*)
            echo "$INTENT_LIST_VMS"
            return $VDE_SUCCESS
            ;;
    esac

    # Check for status (includes common typos: runing, runnig)
    case "$input_lower" in
        *running*|*runing*|*runnig*|*status*|*staus*|*satus*|*"current state"*)
            echo "$INTENT_STATUS"
            return $VDE_SUCCESS
            ;;
    esac

    # Check for connect intent (includes typo: conect)
    case "$input_lower" in
        *"how do i connect"*|*"ssh into"*|*"connect to"*|*"connect "*|*conect*)
            echo "$INTENT_CONNECT"
            return $VDE_SUCCESS
            ;;
    esac

    # Check for create intent (be specific to avoid false matches)
    # Includes typo patterns: cret, crat (prefix omission), craet (transposition)
    # Note: 'creat' removed to avoid false positives with "create directory" etc.
    case "$input_lower" in
        *"create a"*|*"create new"*|*"create "*|*cret*|*crat*|*craet*|*"make a"*|*"make new"*|*"set up"*)
            echo "$INTENT_CREATE_VM"
            return $VDE_SUCCESS
            ;;
    esac

    # Check for restart intent (must be checked before start/stop)
    # Includes typo patterns: restrat, resart (transposition)
    case "$input_lower" in
        *restart*|*restrat*|*resart*|*reatart*|*reboot*|*rebot*|*rebuild*)
            echo "$INTENT_RESTART_VM"
            return $VDE_SUCCESS
            ;;
    esac

    # Check for start intent
    # Includes typo patterns: strt, strat, satrt (transposition), launc (omission)
    # Note: 'stat' removed to avoid collision with status intent
    case "$input_lower" in
        *start*|*strt*|*strat*|*satrt*|*launch*|*launc*|*boot*)
            echo "$INTENT_START_VM"
            return $VDE_SUCCESS
            ;;
    esac

    # Check for stop intent
    # Includes typo patterns: stp, sto (prefix omission), stpo, sotp (transposition)
    case "$input_lower" in
        *stop*|*stp*|*sto*|*stpo*|*sotp*|*shutdown*|*shutdon*|*kill*|*kil*)
            echo "$INTENT_STOP_VM"
            return $VDE_SUCCESS
            ;;
    esac

    # Default: return help intent
    echo "$INTENT_HELP"
    return $VDE_SUCCESS
}

# -----------------------
# Entity Extraction
# -----------------------

# extract_vm_names - Extract VM names from natural language input
# Searches for known VM names and aliases in the input string
# Uses optimized O(1) alias map lookup instead of O(n×m) nested loops
# Args: <input_string> - The user's natural language input
# Returns:
#   VDE_SUCCESS (0) - Always succeeds, outputs VM names to stdout (one per line)
# Output: Newline-separated list of canonical VM names found in input
# Example: vms=$(extract_vm_names "start python and rust")  # outputs "python\nrust"
extract_vm_names() {
    local input="$1"
    local input_lower
    input_lower=$(echo "$input" | tr '[:upper:]' '[:lower:]')

    # Handle "all", "everything" first (before word extraction)
    case "$input_lower" in
        *all*|*everything*)
            get_all_vms
            return $VDE_SUCCESS
            ;;
    esac

    # Handle "all languages"
    case "$input_lower" in
        *"all languages"*|*"all lang"*)
            get_lang_vms
            return $VDE_SUCCESS
            ;;
    esac

    # Handle "all services"
    case "$input_lower" in
        *"all services"*|*"all svc"*)
            get_service_vms
            return $VDE_SUCCESS
            ;;
    esac

    # Ensure alias map is built for O(1) lookups
    _ensure_alias_map

    # Extract words from input and look up each in the alias map
    # This is O(w) where w is the number of words, instead of O(n×m)
    local found_vms=""
    _assoc_init "seen_vms"  # Track already-found VMs to avoid duplicates

    # Declare variables outside loop to avoid zsh subshell scoping issues
    local canonical
    local word

    # Use a temp file to collect results (subshell-safe)
    local tmp_file
    tmp_file=$(mktemp 2>/dev/null || echo "/tmp/vde-extract-$$")

    # Split input into words (alphanumeric sequences)
    # Use explicit splitting for zsh/bash compatibility
    echo "$input_lower" | tr ' ' '\n' | while IFS= read -r word; do
        # Clean the word (remove punctuation, keep only alphanumeric and plus)
        # Note: '#' is removed as it starts comments in shell and is not valid in VM names
        word=$(echo "$word" | tr -cd 'a-z0-9+')
        [ -z "$word" ] && continue

        # O(1) lookup in alias map
        canonical=$(_assoc_get "VM_ALIAS_MAP" "$word" 2>/dev/null)

        if [ -n "$canonical" ]; then
            # Check if we've already seen this VM
            if ! _assoc_has_key "seen_vms" "$canonical"; then
                _assoc_set "seen_vms" "$canonical" "1"
                echo "$canonical" >> "$tmp_file"
            fi
        fi
    done

    # Clean up
    _assoc_clear "seen_vms"

    # Read collected VMs from temp file
    if [ -f "$tmp_file" ]; then
        found_vms=$(cat "$tmp_file" 2>/dev/null | tr '\n' ' ' | sed 's/ $//')
        rm -f "$tmp_file"
    fi

    # Print found VMs
    if [ -n "$found_vms" ]; then
        echo "$found_vms" | tr ' ' '\n'
    fi
    return $VDE_SUCCESS
}

# extract_filter - Extract filter type from input for listing commands
# Determines if user wants to see language VMs, service VMs, or all
# Args: <input_string> - The user's natural language input
# Returns:
#   VDE_SUCCESS (0) - Always succeeds, outputs filter type to stdout
# Output: One of "lang", "svc", or "all"
# Example: filter=$(extract_filter "show all language VMs")  # outputs "lang"
extract_filter() {
    local input="$1"
    local input_lower
    input_lower=$(echo "$input" | tr '[:upper:]' '[:lower:]')

    case "$input_lower" in
        *language*|*lang*)
            echo "lang"
            ;;
        *service*|*svc*)
            echo "svc"
            ;;
        *)
            echo "all"
            ;;
    esac
    return $VDE_SUCCESS
}

# extract_flags - Extract operation flags from input
# Detects rebuild and nocache flags in natural language
# Args: <input_string> - The user's natural language input
# Returns:
#   VDE_SUCCESS (0) - Always succeeds, outputs flags to stdout
# Output: Space-separated key=value pairs (e.g., "rebuild=true nocache=false")
# Example: flags=$(extract_flags "rebuild python with no cache")
extract_flags() {
    local input="$1"
    local input_lower
    input_lower=$(echo "$input" | tr '[:upper:]' '[:lower:]')

    local rebuild="false"
    local nocache="false"

    case "$input_lower" in
        *rebuild*|*"re-create"*)
            rebuild="true"
            ;;
    esac

    case "$input_lower" in
        *"no-cache"*|*"no cache"*|*"from scratch"*)
            nocache="true"
            ;;
    esac

    echo "rebuild=$rebuild nocache=$nocache"
    return $VDE_SUCCESS
}

# -----------------------
# Security: Input Validation Functions
# -----------------------

# SECURITY: Whitelist of allowed plan keys
ALLOWED_PLAN_KEYS="INTENT VM FLAGS FILTER"
readonly ALLOWED_PLAN_KEYS

# SECURITY: Whitelist of allowed flags
ALLOWED_FLAGS="rebuild nocache"
readonly ALLOWED_FLAGS

# contains_dangerous_chars - Check for dangerous shell metacharacters
# SECURITY: Uses explicit character checks to avoid regex compilation issues
# Args: <string> - The string to check
# Returns:
#   VDE_SUCCESS (0) - Dangerous characters found (string is NOT safe)
#   VDE_ERR_NOT_FOUND (3) - No dangerous characters (string is safe)
# Example: contains_dangerous_chars "hello; rm -rf /" && echo "DANGER!"
contains_dangerous_chars() {
    local str="$1"
    # Check for each dangerous character explicitly
    case "$str" in
        *";"*|*"|"*|*"&"*|*'$'*|*'`'*|*"("*|*")"*|*"{"*|*"}"*|*"["*|*"]"*|*"<"*|*">"*|*"!"*|*"#"*|*"*"*|*"?"*|*"\\"*|*'"'*)
            return $VDE_SUCCESS
            ;;
    esac
    return $VDE_ERR_NOT_FOUND
}

# validate_plan_line - Validate a single plan line against whitelist
# SECURITY: Ensures plan lines only contain allowed keys and safe values
# Args: <line> - A single line from a generated plan
# Returns:
#   VDE_SUCCESS (0) - Line is valid
#   VDE_ERR_INVALID_INPUT (2) - Line contains invalid key or dangerous characters
# Example: validate_plan_line "INTENT:start_vm" && echo "Valid"
validate_plan_line() {
    local line="$1"
    
    # Empty lines are valid (skip them)
    [ -z "$line" ] && return $VDE_SUCCESS
    
    # Extract key (everything before first colon)
    local key="${line%%:*}"
    local value="${line#*:}"
    
    # SECURITY: Check if key is in whitelist
    local key_valid=false
    local allowed_key
    # Explicitly word-split ALLOWED_PLAN_KEYS using set
    for allowed_key in $(echo "$ALLOWED_PLAN_KEYS"); do
        if [ "$key" = "$allowed_key" ]; then
            key_valid=true
            break
        fi
    done
    
    if [ "$key_valid" = "false" ]; then
        log_error "SECURITY: Rejected unknown plan key: $key"
        return $VDE_ERR_INVALID_INPUT
    fi
    
    # SECURITY: Check for dangerous shell metacharacters in value
    if contains_dangerous_chars "$value"; then
        log_error "SECURITY: Rejected value containing shell metacharacters: $value"
        return $VDE_ERR_INVALID_INPUT
    fi
    
    return $VDE_SUCCESS
}

# parse_flags - Parse FLAGS value safely without eval
# SECURITY: Only accepts known flags (rebuild, nocache) with boolean values
# Args: <flags_string> - Space-separated key=value pairs
# Returns:
#   VDE_SUCCESS (0) - Flags parsed successfully
#   VDE_ERR_INVALID_INPUT (2) - Invalid flag or value
# Side Effects: Sets 'rebuild' and 'nocache' variables in caller's scope
# Example: parse_flags "rebuild=true nocache=false"
parse_flags() {
    local flags_string="$1"
    
    # Initialize to safe defaults
    rebuild="false"
    nocache="false"
    
    # SECURITY: Reject if contains dangerous characters
    if contains_dangerous_chars "$flags_string"; then
        log_error "SECURITY: Rejected FLAGS containing shell metacharacters"
        return $VDE_ERR_INVALID_INPUT
    fi
    
    # Parse each space-separated token
    local token
    # Explicitly word-split flags_string to ensure proper iteration
    for token in $(echo "$flags_string"); do
        # Extract key=value
        local flag_key="${token%%=*}"
        local flag_value="${token#*=}"
        
        # SECURITY: Only accept whitelisted flags
        case "$flag_key" in
            rebuild)
                if [ "$flag_value" = "true" ]; then
                    rebuild="true"
                elif [ "$flag_value" = "false" ]; then
                    rebuild="false"
                else
                    log_error "SECURITY: Invalid value for rebuild flag: $flag_value"
                    return $VDE_ERR_INVALID_INPUT
                fi
                ;;
            nocache)
                if [ "$flag_value" = "true" ]; then
                    nocache="true"
                elif [ "$flag_value" = "false" ]; then
                    nocache="false"
                else
                    log_error "SECURITY: Invalid value for nocache flag: $flag_value"
                    return $VDE_ERR_INVALID_INPUT
                fi
                ;;
            *)
                log_error "SECURITY: Rejected unknown flag: $flag_key"
                return $VDE_ERR_INVALID_INPUT
                ;;
        esac
    done
    
    return $VDE_SUCCESS
}

# validate_vm_name_security - Validate VM name against known VMs
# SECURITY: Ensures VM name is safe and exists in configuration
# Args: <vm_name> - The VM name to validate
# Returns:
#   VDE_SUCCESS (0) - VM name is valid and known
#   VDE_ERR_INVALID_INPUT (2) - VM name contains dangerous characters
#   VDE_ERR_NOT_FOUND (3) - VM name not in known VMs list
# Example: validate_vm_name_security "python" && echo "Valid VM"
validate_vm_name_security() {
    local vm_name="$1"
    
    # SECURITY: Check for dangerous characters first
    if contains_dangerous_chars "$vm_name"; then
        log_error "SECURITY: VM name contains dangerous characters: $vm_name"
        return $VDE_ERR_INVALID_INPUT
    fi
    
    # Check against known VMs
    local known_vms
    known_vms=$(get_all_vms 2>/dev/null)
    
    local known
    for known in $known_vms; do
        if [ "$vm_name" = "$known" ]; then
            return $VDE_SUCCESS
        fi
    done
    
    log_error "SECURITY: Unknown VM name: $vm_name"
    return $VDE_ERR_NOT_FOUND
}

# -----------------------
# User Confirmation
# -----------------------

# prompt_confirm_unknown_vm - Prompt user to confirm creating an unknown VM type
# This prevents accidental VM creation when user may have meant something else
# Args: <vm_name> - The unknown VM name to confirm
# Returns:
#   0 - User confirmed (proceed with creation)
#   1 - User declined (abort creation)
# Example: if prompt_confirm_unknown_vm "directory"; then create_vm; fi
prompt_confirm_unknown_vm() {
    local vm_name="$1"

    # Validate input
    [ -n "$vm_name" ] || return 1

    local available
    available=$(vde_list_vms 2>/dev/null | tr '\n' ' ')
    available="${available% }"  # Remove trailing space

    # Check if we can open /dev/tty for interactive input
    if ! exec 3</dev/tty 2>/dev/null; then
        # Non-interactive mode (piped input, script, etc.)
        log_error "Unknown VM type: '$vm_name'"
        log_error "Available VMs: $available"
        log_error "Cannot confirm in non-interactive mode. Aborting."
        return 1
    fi
    exec 3<&-  # Close the test descriptor

    # Display warning and available VMs
    echo >&2
    echo "WARNING: '$vm_name' is not a known VM type." >&2
    echo >&2
    echo "Available VM types:" >&2
    echo "  $available" >&2
    echo >&2
    echo -n "Did you mean to create a VM called '$vm_name' anyway? [y/N] " >&2
    read -r response </dev/tty

    case "$response" in
        [yY]|[yY][eE][sS])
            echo "Proceeding with VM creation for '$vm_name'..." >&2
            return 0
            ;;
        *)
            echo "VM creation aborted." >&2
            return 1
            ;;
    esac
}

# -----------------------
# Command Generation
# -----------------------

# generate_plan - Generate an execution plan from natural language input
# Parses user input and creates a structured plan for execution
# Args: <input_string> - The user's natural language input
# Returns:
#   VDE_SUCCESS (0) - Plan generated successfully
# Output: Multi-line structured plan with format:
#   INTENT:<intent_constant>
#   VM:<space-separated vm names>
#   FLAGS:<key=value pairs>
#   FILTER:<all|lang|svc>
# Example: generate_plan "start python and rust"
generate_plan() {
    local input="$1"

    # Detect intent
    local intent
    intent=$(detect_intent "$input")

    # Extract entities based on intent
    local vms=""
    local flags=""
    local filter="all"

    case "$intent" in
        "$INTENT_LIST_VMS")
            filter=$(extract_filter "$input")
            ;;
        "$INTENT_CREATE_VM"|"$INTENT_START_VM"|"$INTENT_STOP_VM"|"$INTENT_RESTART_VM"|"$INTENT_STATUS"|"$INTENT_CONNECT")
            vms=$(extract_vm_names "$input")
            flags=$(extract_flags "$input")
            ;;
    esac

    # Output plan
    echo "INTENT:$intent"
    # Convert newlines to spaces for VMs
    if [ -n "$vms" ]; then
        local vm_list
        vm_list=$(echo "$vms" | tr '\n' ' ' | sed 's/ $//')
        echo "VM:$vm_list"
    fi
    [ -n "$flags" ] && echo "FLAGS:$flags"
    [ -n "$filter" ] && echo "FILTER:$filter"
    
    return $VDE_SUCCESS
}

# -----------------------
# Plan Execution
# -----------------------

# execute_plan - Execute a generated plan
# Reads a structured plan from stdin and executes the corresponding VDE commands
# Args: none (reads plan from stdin)
# Returns:
#   VDE_SUCCESS (0) - Plan executed successfully
#   VDE_ERR_INVALID_INPUT (2) - Plan validation failed or missing required data
#   VDE_ERR_NOT_FOUND (3) - Referenced VM not found
#   Other codes from underlying VDE commands
# Example: echo "INTENT:start_vm\nVM:python" | execute_plan
execute_plan() {
    local intent=""
    local vms=""
    local rebuild="false"
    local nocache="false"
    local filter="all"

    # Parse plan from stdin
    while IFS= read -r line; do
        # SECURITY: Validate each line before processing
        if ! validate_plan_line "$line"; then
            log_error "SECURITY: Plan validation failed, aborting execution"
            return $VDE_ERR_INVALID_INPUT
        fi
        
        local key="${line%%:*}"
        local value="${line#*:}"

        case "$key" in
            INTENT)
                intent="$value"
                ;;
            VM)
                local vm_list
                vm_list=$(echo "$value" | tr '\n' ' ')
                # Trim trailing whitespace
                vm_list=$(echo "$vm_list" | sed 's/[[:space:]]*$//')
                vms="$vm_list"
                
                # SECURITY: Validate each VM name (warn but don't fail for flexibility)
                local vm
                for vm in $vms; do
                    if ! validate_vm_name_security "$vm" 2>/dev/null; then
                        log_error "Warning: VM '$vm' not in known VM list"
                    fi
                done
                ;;
            FLAGS)
                # SECURITY: Use safe flag parsing instead of eval
                # This replaces the dangerous: eval "$value"
                if ! parse_flags "$value"; then
                    log_error "SECURITY: Invalid FLAGS value, aborting"
                    return $VDE_ERR_INVALID_INPUT
                fi
                ;;
            FILTER)
                # SECURITY: Validate filter value
                case "$value" in
                    all|lang|svc)
                        filter="$value"
                        ;;
                    *)
                        log_error "SECURITY: Invalid FILTER value: $value"
                        return $VDE_ERR_INVALID_INPUT
                        ;;
                esac
                ;;
        esac
    done

    # Count VMs
    local vm_count=0
    local vm
    for vm in $vms; do
        [ -n "$vm" ] && vm_count=$((vm_count + 1))
    done

    # Execute based on intent
    case "$intent" in
        "$INTENT_LIST_VMS")
            vde_list_vms "--$filter"
            return $?
            ;;

        "$INTENT_STATUS")
            if [ $vm_count -eq 0 ]; then
                vde_get_running_vms
            else
                for vm in $vms; do
                    [ -n "$vm" ] || continue
                    local vm_status
                    vm_status=$(vde_get_vm_status "$vm")
                    echo "$vm: $vm_status"
                done
            fi
            return $VDE_SUCCESS
            ;;

        "$INTENT_CREATE_VM")
            if [ $vm_count -eq 0 ]; then
                log_error "No VM specified. Please specify which VM to create."
                return $VDE_ERR_INVALID_INPUT
            fi

            for vm in $vms; do
                [ -n "$vm" ] || continue
                if ! vde_validate_vm_type "$vm"; then
                    # Unknown VM type - prompt user to confirm
                    if ! prompt_confirm_unknown_vm "$vm"; then
                        return $VDE_ERR_NOT_FOUND
                    fi
                    # User confirmed - proceed with creation attempt
                    # (vde_create_vm will fail if the VM type truly doesn't exist)
                fi

                if vde_vm_exists "$vm"; then
                    log_info "VM $vm already exists. Skipping creation."
                else
                    vde_create_vm "$vm" || return $?
                fi
            done
            return $VDE_SUCCESS
            ;;

        "$INTENT_START_VM")
            if [ $vm_count -eq 0 ]; then
                log_error "No VM specified. Please specify which VM to start."
                return $VDE_ERR_INVALID_INPUT
            fi

            for vm in $vms; do
                [ -n "$vm" ] || continue
                if ! vde_vm_exists "$vm"; then
                    log_error "VM $vm does not exist. Create it first."
                    return $VDE_ERR_NOT_FOUND
                fi
            done

            # Build args string with flags and VMs
            local start_args=""
            [ "$rebuild" = "true" ] && start_args="--rebuild"
            [ "$nocache" = "true" ] && start_args="$start_args --no-cache"
            start_args="$start_args $vms"

            vde_start_multiple_vms $start_args
            return $?
            ;;

        "$INTENT_STOP_VM")
            if [ $vm_count -eq 0 ]; then
                log_error "No VM specified. Please specify which VM to stop."
                return $VDE_ERR_INVALID_INPUT
            fi

            vde_stop_multiple_vms $vms
            return $?
            ;;

        "$INTENT_RESTART_VM")
            if [ $vm_count -eq 0 ]; then
                log_error "No VM specified. Please specify which VM to restart."
                return $VDE_ERR_INVALID_INPUT
            fi

            for vm in $vms; do
                [ -n "$vm" ] || continue
                vde_restart_vm "$vm" "$rebuild" "$nocache"
            done
            return $VDE_SUCCESS
            ;;

        "$INTENT_CONNECT")
            if [ $vm_count -eq 0 ]; then
                log_error "No VM specified. Please specify which VM you want to connect to."
                return $VDE_ERR_INVALID_INPUT
            fi

            for vm in $vms; do
                [ -n "$vm" ] || continue
                local ssh_info
                ssh_info=$(vde_get_ssh_info "$vm")

                if [ -z "$ssh_info" ]; then
                    log_error "Could not get SSH info for $vm"
                else
                    local ssh_host="${ssh_info%%|*}"
                    local ssh_port="${ssh_info##*|}"
                    echo "To connect to $vm:"
                    echo "  SSH command: ssh $ssh_host"
                    echo "  Port: $ssh_port"
                    echo "  Or use VSCode Remote-SSH with host: $ssh_host"
                fi
            done
            return $VDE_SUCCESS
            ;;

        "$INTENT_HELP")
            show_parser_help
            return $VDE_SUCCESS
            ;;

        *)
            log_error "Unknown intent: $intent"
            show_parser_help
            return $VDE_ERR_INVALID_INPUT
            ;;
    esac
}

# -----------------------
# Help Display
# -----------------------

# show_parser_help - Display help information for the VDE Natural Language Parser
# Shows supported intents, example commands, and usage options
# Args: none
# Returns: VDE_SUCCESS (0)
# Example: show_parser_help
show_parser_help() {
    echo "VDE Natural Language Parser - Pattern-Based Command Understanding"
    echo ""
    echo "The VDE Natural Language Parser helps you control your Virtual Development Environment"
    echo "using natural language commands through pattern matching (no external dependencies)."
    echo ""
    echo "SUPPORTED INTENTS:"
    echo "  List VMs"
    echo "    what VMs can I create?"
    echo "    show all languages"
    echo "    list services"
    echo ""
    echo "  Create VMs"
    echo "    create a Go VM"
    echo "    make a Python container"
    echo "    set up Rust and PostgreSQL"
    echo ""
    echo "  Start VMs"
    echo "    start Go"
    echo "    start Python and Rust"
    echo "    start everything"
    echo ""
    echo "  Stop VMs"
    echo "    stop Go"
    echo "    shutdown everything"
    echo ""
    echo "  Restart VMs"
    echo "    restart Python"
    echo "    rebuild and start Go"
    echo ""
    echo "  Status"
    echo "    what is running?"
    echo "    show status of all VMs"
    echo ""
    echo "  Connection Info"
    echo "    how do I connect to Python?"
    echo "    SSH into Go VM"
    echo ""
    echo "  Help"
    echo "    help"
    echo "    what can I do?"
    echo ""
    echo "OPTIONS:"
    echo "  --dry-run    Show what would happen without executing"
    echo ""
    echo "EXAMPLES:"
    echo "  vde-nlp create a Go VM and start it"
    echo "  vde-nlp what is currently running?"
    echo "  vde-nlp start Python and PostgreSQL"
    echo "  vde-nlp stop everything"

    return $VDE_SUCCESS
}
