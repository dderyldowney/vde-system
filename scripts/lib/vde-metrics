#!/bin/zsh
#===============================================================================
# vde-metrics - Metrics Collection Library for VDE
# Tracks performance metrics, command latency, and error rates
#===============================================================================

# Source dependencies
[[ -z "$VDE_ROOT_DIR" ]] && VDE_ROOT_DIR="${0:a:h:h}"
[[ -f "$VDE_ROOT_DIR/scripts/lib/vde-constants" ]] && source "$VDE_ROOT_DIR/scripts/lib/vde-constants"
[[ -f "$VDE_ROOT_DIR/scripts/lib/vde-shell-compat" ]] && source "$VDE_ROOT_DIR/scripts/lib/vde-shell-compat"
[[ -f "$VDE_ROOT_DIR/scripts/lib/vde-log" ]] && source "$VDE_ROOT_DIR/scripts/lib/vde-log"

#===============================================================================
# Metrics Configuration
#===============================================================================

# Metrics storage file
VDE_METRICS_FILE="${VDE_ROOT_DIR}/.cache/vde-metrics.json"

# Metrics categories
VDE_METRICS_COMMAND_LATENCY="command.latency"
VDE_METRICS_CONTAINER_START="container.start_time"
VDE_METRICS_ERROR_RATE="error.rate"
VDE_METRICS_CACHE_HIT_RATE="cache.hit_rate"

# Current runtime state
_VDE_METRICS_INITIALIZED=0
declare -A _VDE_METRICS_TIMERS=()
declare -A _VDE_METRICS_COUNTERS=()

#===============================================================================
# Initialization
#===============================================================================

# Initialize metrics system
vde_metrics_init() {
    # Create cache directory if it doesn't exist
    if [[ ! -d "$VDE_ROOT_DIR/.cache" ]]; then
        command mkdir -p "$VDE_ROOT_DIR/.cache" 2>/dev/null || return 1
    fi
    
    # Create metrics file if it doesn't exist
    if [[ ! -f "$VDE_METRICS_FILE" ]]; then
        echo '{"metrics": {}, "timings": {}, "counters": {}, "last_updated": "'$(vde_shell_date_iso8601)'"}' > "$VDE_METRICS_FILE"
    fi
    
    # Ensure file is writable
    if [[ ! -w "$VDE_METRICS_FILE" ]]; then
        return 1
    fi
    
    _VDE_METRICS_INITIALIZED=1
    
    vde_log_info "Metrics system initialized" "metrics"
    return 0
}

#===============================================================================
# Metric Recording
#===============================================================================

# Record a metric value
# Args: metric_name, value, [unit]
vde_metrics_record() {
    local metric_name="$1"
    local value="$2"
    local unit="${3:-count}"
    
    # Check if metrics are initialized
    if [[ "$_VDE_METRICS_INITIALIZED" -eq 0 ]]; then
        vde_metrics_init || return 1
    fi
    
    # Update in-memory counter
    _VDE_METRICS_COUNTERS["$metric_name"]=$((${_VDE_METRICS_COUNTERS[$metric_name]:-0} + 1))
    
    # Get current metrics file content
    local metrics_json
    metrics_json=$(command cat "$VDE_METRICS_FILE" 2>/dev/null)
    
    if [[ -z "$metrics_json" ]]; then
        metrics_json='{"metrics": {}, "timings": {}, "counters": {}, "last_updated": "'$(vde_shell_date_iso8601)'"}'
    fi
    
    # Escape metric name for JSON
    local escaped_name
    escaped_name=$(echo "$metric_name" | command sed 's/"/\\"/g')
    
    # Add/update metric value
    # Simple approach: append to metrics object
    local timestamp
    timestamp=$(vde_shell_date_iso8601)
    
    # Create new metric entry
    local new_entry="{\"value\": $value, \"unit\": \"$unit\", \"timestamp\": \"$timestamp\"}"
    
    # Use jq if available, otherwise fallback to simple append
    if command -v jq >/dev/null 2>&1; then
        echo "$metrics_json" | jq --arg n "$escaped_name" --argjson v "$new_entry" \
            '.metrics[$n] = .metrics[$n] // [] | .metrics[$n] += [$v] | .last_updated = "'"$timestamp"'"' > "$VDE_METRICS_FILE.$$" 2>/dev/null
        command mv "$VDE_METRICS_FILE.$$" "$VDE_METRICS_FILE" 2>/dev/null
    else
        # Fallback: just append to counters in memory
        _VDE_METRICS_COUNTERS["$metric_name"]=$((${_VDE_METRICS_COUNTERS[$metric_name]:-0} + value))
    fi
    
    return 0
}

# Increment a counter metric
# Args: metric_name, [increment]
vde_metrics_increment() {
    local metric_name="$1"
    local increment="${2:-1}"
    vde_metrics_record "$metric_name" "$increment" "count"
}

# Decrement a counter metric
# Args: metric_name, [decrement]
vde_metrics_decrement() {
    local metric_name="$1"
    local decrement="${2:-1}"
    vde_metrics_record "$metric_name" "-$decrement" "count"
}

#===============================================================================
# Timing Functions
#===============================================================================

# Start timing an operation
# Args: operation_name
vde_metrics_timing_start() {
    local operation="$1"
    _VDE_METRICS_TIMERS["$operation"]=$(vde_shell_date_epoch)
}

# End timing an operation and record
# Args: operation_name, [metric_name]
vde_metrics_timing_end() {
    local operation="$1"
    local metric_name="${2:-${VDE_METRICS_COMMAND_LATENCY}}"
    
    local start_time="${_VDE_METRICS_TIMERS[$operation]:-0}"
    local end_time
    end_time=$(vde_shell_date_epoch)
    
    local duration=$((end_time - start_time))
    
    if [[ "$duration" -gt 0 ]]; then
        vde_metrics_record "$metric_name" "$duration" "milliseconds"
    fi
    
    # Clear timer
    unset "_VDE_METRICS_TIMERS[$operation]"
    
    return 0
}

# Time a command execution
# Args: metric_name, command
vde_metrics_time_command() {
    local metric_name="$1"
    shift
    local cmd="$@"
    
    vde_metrics_timing_start "$metric_name"
    eval "$cmd"
    vde_metrics_timing_end "$metric_name"
}

#===============================================================================
# Metric Retrieval
#===============================================================================

# Get metrics
# Args: [metric_name_pattern]
vde_metrics_get() {
    local pattern="${1:-.*}"
    
    if [[ -f "$VDE_METRICS_FILE" ]]; then
        if command -v jq >/dev/null 2>&1; then
            command jq -r ".metrics | to_entries[] | select(.key | test(\"$pattern\")) | \"\(.key): \(.value)\"" "$VDE_METRICS_FILE" 2>/dev/null || true
        else
            command cat "$VDE_METRICS_FILE"
        fi
    fi
}

# Get a specific metric value
# Args: metric_name
vde_metrics_get_value() {
    local metric_name="$1"
    
    if [[ -f "$VDE_METRICS_FILE" ]]; then
        if command -v jq >/dev/null 2>&1; then
            command jq -r ".metrics[\"$metric_name\"] | last | .value // 0" "$VDE_METRICS_FILE" 2>/dev/null || echo "0"
        fi
    fi
}

# Get metrics statistics
vde_metrics_stats() {
    if [[ -f "$VDE_METRICS_FILE" ]]; then
        if command -v jq >/dev/null 2>&1; then
            command jq '{
                total_metrics: (.metrics | length),
                last_updated: .last_updated,
                sample_metrics: .metrics | to_entries |.[0:5] | map("\(.key): \(.value | length) entries")
            }' "$VDE_METRICS_FILE" 2>/dev/null || true
        else
            command cat "$VDE_METRICS_FILE"
        fi
    fi
}

#===============================================================================
# Metrics Export
#===============================================================================

# Export metrics to JSON
vde_metrics_export() {
    local output_file="${1:-${VDE_ROOT_DIR}/logs/vde-metrics-export.json}"
    
    if [[ -f "$VDE_METRICS_FILE" ]]; then
        command cp "$VDE_METRICS_FILE" "$output_file"
        return 0
    fi
    return 1
}

# Export metrics summary
vde_metrics_summary() {
    echo "Metrics Summary"
    echo "==============="
    
    if [[ -f "$VDE_METRICS_FILE" ]]; then
        local total_entries
        total_entries=$(command jq '.metrics | map_values(length) | values | add // 0' "$VDE_METRICS_FILE" 2>/dev/null || echo "0")
        echo "Total metric entries: $total_entries"
        echo ""
        echo "Recent metrics:"
        command jq -r '.metrics | to_entries[] | "  \(.key): \(.value | length) entries"' "$VDE_METRICS_FILE" 2>/dev/null || true
    fi
}

#===============================================================================
# Metrics Reset
#===============================================================================

# Reset all metrics
vde_metrics_reset() {
    if [[ "$_VDE_METRICS_INITIALIZED" -eq 0 ]]; then
        vde_metrics_init || return 1
    fi
    
    echo '{"metrics": {}, "timings": {}, "counters": {}, "last_updated": "'$(vde_shell_date_iso8601)'"}' > "$VDE_METRICS_FILE"
    
    # Clear in-memory counters
    _VDE_METRICS_COUNTERS=()
    _VDE_METRICS_TIMERS=()
    
    vde_log_info "Metrics reset" "metrics"
    return 0
}

#===============================================================================
# Common Metrics Helpers
#===============================================================================

# Record command latency
vde_metrics_record_command_latency() {
    local command_name="$1"
    local duration="$2"
    vde_metrics_record "${VDE_METRICS_COMMAND_LATENCY}.$command_name" "$duration" "milliseconds"
}

# Record container start time
vde_metrics_record_container_start() {
    local container_name="$1"
    local duration="$2"
    vde_metrics_record "${VDE_METRICS_CONTAINER_START}.$container_name" "$duration" "milliseconds"
}

# Record error
vde_metrics_record_error() {
    local error_type="$1"
    vde_metrics_record "${VDE_METRICS_ERROR_RATE}.$error_type" 1 "count"
}

# Record cache hit
vde_metrics_record_cache_hit() {
    vde_metrics_record "${VDE_METRICS_CACHE_HIT_RATE}.hit" 1 "count"
}

# Record cache miss
vde_metrics_record_cache_miss() {
    vde_metrics_record "${VDE_METRICS_CACHE_HIT_RATE}.miss" 1 "count"
}

# Get cache hit rate percentage
vde_metrics_get_cache_hit_rate() {
    if [[ -f "$VDE_METRICS_FILE" ]]; then
        if command -v jq >/dev/null 2>&1; then
            local hits=$(command jq -r ".metrics[\"${VDE_METRICS_CACHE_HIT_RATE}.hit\"] | length // 0" "$VDE_METRICS_FILE" 2>/dev/null || echo "0")
            local misses=$(command jq -r ".metrics[\"${VDE_METRICS_CACHE_HIT_RATE}.miss\"] | length // 0" "$VDE_METRICS_FILE" 2>/dev/null || echo "0")
            local total=$((hits + misses))
            if [[ "$total" -gt 0 ]]; then
                echo $((hits * 100 / total))
            else
                echo "0"
            fi
        fi
    fi
}

#===============================================================================
# Backward Compatibility
#===============================================================================

# Export functions
export -f vde_metrics_init >/dev/null 2>&1 || true
export -f vde_metrics_record >/dev/null 2>&1 || true
export -f vde_metrics_increment >/dev/null 2>&1 || true
export -f vde_metrics_decrement >/dev/null 2>&1 || true
export -f vde_metrics_timing_start >/dev/null 2>&1 || true
export -f vde_metrics_timing_end >/dev/null 2>&1 || true
export -f vde_metrics_time_command >/dev/null 2>&1 || true
export -f vde_metrics_get >/dev/null 2>&1 || true
export -f vde_metrics_export >/dev/null 2>&1 || true
export -f vde_metrics_reset >/dev/null 2>&1 || true
