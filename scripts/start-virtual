#!/usr/bin/env zsh
set -e

# Source shared library
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
source "$SCRIPT_DIR/lib/vm-common"
source "$SCRIPT_DIR/lib/vde-docker-state"

# Parse arguments
if [[ $# -eq 0 ]]; then
    echo "Usage: start-virtual <vm_name1> [vm_name2] ... [--rebuild] [--no-cache] [--update-ssh]"
    echo ""
    echo "Examples:"
    echo "  start-virtual python                    # Start single VM"
    echo "  start-virtual python ruby js            # Start multiple VMs"
    echo "  start-virtual all                       # Start all VMs"
    echo "  start-virtual python --rebuild          # Rebuild and start"
    echo "  start-virtual all --no-cache            # Full rebuild all VMs"
    echo "  start-virtual python --update-ssh       # Start and regenerate SSH config"
    echo ""
    show_known_vms
    exit 1
fi

# Parse VMs and flags separately
VMS=()
REBUILD=false
NOCACHE=false
UPDATE_SSH=false

for arg in "$@"; do
    case $arg in
        --rebuild)
            REBUILD=true
            ;;
        --no-cache)
            NOCACHE=true
            ;;
        --update-ssh|--update-ssh-keys)
            UPDATE_SSH=true
            ;;
        all)
            # Expand "all" to all known VMs
            for vm in $(get_all_vms); do
                VMS+=("$vm")
            done
            ;;
        *)
            # Check if it's a known VM or VM type
            local resolved
            resolved=$(resolve_vm_name "$arg" || true)
            if [[ -n "$resolved" ]]; then
                VMS+=("$resolved")
            else
                vde_error_vm_not_found "$arg"
                exit 1
            fi
            ;;
    esac
done

# If no VMs specified (e.g., only flags), show usage
if [[ ${#VMS[@]} -eq 0 ]]; then
    echo "Usage: start-virtual <vm_name1> [vm_name2] ... [--rebuild] [--no-cache] [--update-ssh]"
    echo ""
    show_known_vms
    exit 1
fi

# Ensure SSH environment (automatic & silent)
# Starts SSH agent, loads keys, generates VM config - all without user interaction
ensure_ssh_environment

# Track batch operation results with zsh associative arrays
typeset -gA BATCH_RESULTS
local started_count=0
local skipped_count=0
local failed_count=0

# Start VMs
log_info "Starting ${#VMS[@]} VM(s)..."
for vm in "${VMS[@]}"; do
    if ! is_known_vm "$vm"; then
        vde_error_vm_not_found "$vm"
        BATCH_RESULTS[$vm]="failed:unknown"
        failed_count=$((failed_count + 1))
        continue
    fi

    # Check if VM container exists (real-time Docker data)
    if ! vm_container_exists "$vm"; then
        vde_error_vm_not_created "$vm"
        BATCH_RESULTS[$vm]="failed:not_created"
        failed_count=$((failed_count + 1))
        continue
    fi

    # Check if VM is already running (batch state awareness)
    if vm_is_container_running "$vm"; then
        log_info "$vm is already running - skipped"
        BATCH_RESULTS[$vm]="skipped:already_running"
        skipped_count=$((skipped_count + 1))
        continue
    fi

    # Try to start the VM
    if start_vm "$vm" "$REBUILD" "$NOCACHE"; then
        log_success "$vm started successfully"
        BATCH_RESULTS[$vm]="started"
        started_count=$((started_count + 1))
    else
        log_error "$vm failed to start"
        BATCH_RESULTS[$vm]="failed:start_error"
        failed_count=$((failed_count + 1))
    fi
done

# Display detailed batch operation summary
echo ""
log_info "Batch operation summary:"

# Show started VMs
if [ $started_count -gt 0 ]; then
    log_success "Started: $started_count VM(s)"
    # Check if BATCH_RESULTS has elements before iterating
    if [[ ${#BATCH_RESULTS[@]} -gt 0 ]]; then
        for vm in "${(@k)BATCH_RESULTS[@]}"; do
            if [ "${BATCH_RESULTS[$vm]}" = "started" ]; then
                log_info "  ✓ $vm - started"
            fi
        done
    fi
fi

# Show skipped VMs
if [ $skipped_count -gt 0 ]; then
    log_info "Skipped: $skipped_count VM(s)"
    if [[ ${#BATCH_RESULTS[@]} -gt 0 ]]; then
        for vm in "${(@k)BATCH_RESULTS[@]}"; do
            case "${BATCH_RESULTS[$vm]}" in
                skipped:already_running)
                    log_info "  ○ $vm - already running"
                    ;;
                skipped:not_created)
                    log_warning "  ○ $vm - not created"
                    ;;
            esac
        done
    fi
fi

# Show failed VMs
if [ $failed_count -gt 0 ]; then
    log_error "Failed: $failed_count VM(s)"
    if [[ ${#BATCH_RESULTS[@]} -gt 0 ]]; then
        for vm in "${(@k)BATCH_RESULTS[@]}"; do
            if [[ "${BATCH_RESULTS[$vm]}" = "failed:"* ]]; then
                local error_type="${BATCH_RESULTS[$vm]#*:}"
                log_error "  ✗ $vm - $error_type"
            fi
        done
    fi
fi

log_success "VM startup complete!"

# Update SSH config if requested
if [[ "$UPDATE_SSH" == "true" ]]; then
    echo ""
    log_info "Regenerating VDE SSH config..."
    if generate_vm_ssh_config; then
        log_success "✓ VDE SSH config updated"
    else
        log_warning "⚠ VDE SSH config generation had issues"
    fi
fi
