#!/usr/bin/env zsh
# VDE Chat - Enhanced Interactive AI Assistant CLI
# Interactive chat interface for controlling the VDE system
#
# Usage: vde-chat [OPTIONS]
#
# Options:
#   --ai         Enable LLM-based parsing (requires API key)
#   --persistent Enable persistent session (saves history)
#   --help, -h   Show help message
#
# Keyboard Shortcuts:
#   Enter        Submit command
#   Ctrl+D       Submit multi-line input
#   Ctrl+R       Search command history
#   Ctrl+L       Clear screen
#   Ctrl+C       Cancel current input
#
# Commands:
#   Type your natural language commands and press Enter
#   Type "exit", "quit", or "bye" to leave
#   Type "help" for available commands

setopt EXTENDED_GLOB

# -----------------------
# Configuration
# -----------------------
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
VDE_ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Source libraries
source "$SCRIPT_DIR/lib/vm-common"
source "$SCRIPT_DIR/lib/vde-commands"
source "$SCRIPT_DIR/lib/vde-parser"

# Try to source the AI API library (optional - for LLM-based parsing)
if [[ -f "$SCRIPT_DIR/lib/vde-ai-api" ]]; then
    source "$SCRIPT_DIR/lib/vde-ai-api"
    AI_API_AVAILABLE=true
else
    AI_API_AVAILABLE=false
fi

# Try to source new UX libraries (optional)
if [[ -f "$SCRIPT_DIR/lib/vde-progress" ]]; then
    source "$SCRIPT_DIR/lib/vde-progress"
fi
if [[ -f "$SCRIPT_DIR/lib/vde-errors" ]]; then
    source "$SCRIPT_DIR/lib/vde-errors"
fi

USE_AI=false
PERSISTENT=false
SESSION_HISTORY=()
FILE_HISTORY="$HOME/.vde/history"

# AI Configuration
VDE_AI_BASE_URL="${ANTHROPIC_BASE_URL:-}"
VDE_AI_MODEL="${ANTHROPIC_MODEL:-}"
VDE_AI_DEFAULT_SONNET_MODEL="${ANTHROPIC_DEFAULT_SONNET_MODEL:-}"

# Command aliases for chat mode
declare -A CHAT_ALIASES=(
    ["ls"]="list"
    ["list"]="list-vms"
    ["ps"]="list-vms"
    ["status"]="list-vms"
    ["rm"]="delete"
    ["del"]="delete"
    ["remove"]="delete"
    ["mk"]="create-virtual-for"
    ["create"]="create-virtual-for"
    ["start"]="start-virtual"
    ["stop"]="shutdown-virtual"
    ["shutdown"]="shutdown-virtual"
    ["connect"]="ssh"
    ["ssh"]="ssh"
    ["exit"]="quit"
    ["bye"]="quit"
    ["cls"]="clear"
    ["clear"]="clear"
    ["h"]="history"
    ["hist"]="history"
    ["?"]="help"
)

# -----------------------
# Colors and Formatting
# -----------------------
if [[ -t 1 ]]; then
    COLOR_RESET='\033[0m'
    COLOR_PROMPT='\033[1;36m'    # Cyan
    COLOR_AI='\033[1;33m'        # Yellow
    COLOR_SUCCESS='\033[1;32m'   # Green
    COLOR_ERROR='\033[1;31m'     # Red
    COLOR_INFO='\033[1;34m'      # Blue
    COLOR_DIM='\033[2m'          # Dim
    COLOR_INPUT='\033[0;36m'     # Dark cyan for input
else
    COLOR_RESET=''
    COLOR_PROMPT=''
    COLOR_AI=''
    COLOR_SUCCESS=''
    COLOR_ERROR=''
    COLOR_INFO=''
    COLOR_DIM=''
    COLOR_INPUT=''
fi

# -----------------------
# History Management
# -----------------------

# Load history from file
load_history() {
    if [[ -f "$FILE_HISTORY" ]]; then
        while IFS= read -r line; do
            [[ -n "$line" ]] && SESSION_HISTORY+=("$line")
        done < "$FILE_HISTORY"
    fi
}

# Save history to file
save_history() {
    mkdir -p "$(dirname "$FILE_HISTORY")"
    # Keep only last 1000 commands
    tail -n 1000 "$FILE_HISTORY" 2>/dev/null > "$FILE_HISTORY.tmp"
    for cmd in "${SESSION_HISTORY[@]}"; do
        echo "$cmd" >> "$FILE_HISTORY.tmp"
    done
    mv "$FILE_HISTORY.tmp" "$FILE_HISTORY"
}

# Search history
search_history() {
    local pattern="$1"
    local results=()
    for cmd in "${SESSION_HISTORY[@]}"; do
        if [[ "$cmd" == *"$pattern"* ]]; then
            results+=("$cmd")
        fi
    done
    printf '%s\n' "${results[@]}"
}

# -----------------------
# Usage
# -----------------------
show_usage() {
    cat <<'EOF'
Usage: vde-chat [OPTIONS]

Interactive chat interface for controlling the VDE system.

OPTIONS:
  --ai, -a         Enable LLM-based parsing (requires API key)
  --persistent, -p Enable persistent session (saves command history)
  --help, -h       Show this help message
  --verbose, -v    Enable verbose output

ENVIRONMENT VARIABLES:
  VDE_USE_AI                 Set to "1", "true", or "yes" to enable LLM parsing
  ANTHROPIC_AUTH_TOKEN       Your Anthropic authentication token (highest priority)
  ANTHROPIC_API_KEY          Your Anthropic API key
  CLAUDE_API_KEY             Your Claude API key (legacy)

KEYBOARD SHORTCUTS:
  Enter        Submit command or add new line in multi-line mode
  Ctrl+D       Submit multi-line input
  Ctrl+R       Search command history
  Ctrl+L       Clear screen
  Ctrl+C       Cancel current input / Exit (at empty prompt)

COMMANDS:
  ls, list, ps         List VMs
  create <type> [name] Create a new VM
  start <name>         Start a VM
  stop <name>          Stop a VM
  delete <name>        Delete a VM
  ssh <name>           SSH into a VM
  help                 Show help
  clear, cls           Clear screen
  history, h           Show command history
  quit, exit, bye      Exit chat mode

EXAMPLES:
  [VDE] → create a Python VM
  [VDE] → start python-dev
  [VDE] → what's running?
  [VDE] → list all my VMs

For more information, see: README.md#vde-chat
EOF
}

# -----------------------
# Parse Arguments
# -----------------------
while [[ $# -gt 0 ]]; do
    case $1 in
        --ai|-a)
            USE_AI=true
            shift
            ;;
        --persistent|-p)
            PERSISTENT=true
            shift
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        --verbose|-v)
            export VDE_ERRORS_VERBOSE=1
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Check for VDE_USE_AI environment variable
if [[ "$USE_AI" == "false" ]]; then
    case "${VDE_USE_AI:-}" in
        1|true|yes|TRUE|YES|True)
            USE_AI=true
            ;;
    esac
fi

# Check for API key if AI mode is enabled
if [[ "$USE_AI" == "true" ]]; then
    if [[ -z "${CLAUDE_API_KEY:-}" ]] && [[ -z "${ANTHROPIC_API_KEY:-}" ]]; then
        log_error "AI mode requested but no API key found"
        log_error "Set CLAUDE_API_KEY or ANTHROPIC_API_KEY environment variable"
        log_error "Falling back to pattern-based parsing..."
        USE_AI=false
    fi
fi

# Load VM types
load_vm_types || {
    log_error "Failed to load VM types"
    exit 1
}

# Load history if persistent
if [[ "$PERSISTENT" == "true" ]]; then
    load_history
fi

# -----------------------
# Session Management
# -----------------------

add_to_history() {
    local cmd="$1"
    # Don't add empty or duplicate commands
    [[ -z "$cmd" ]] && return
    local last_cmd="${SESSION_HISTORY[-1]:-}"
    [[ "$cmd" == "$last_cmd" ]] && return
    SESSION_HISTORY+=("$cmd")
    
    # Save periodically (every 10 commands)
    if [[ "$PERSISTENT" == "true" ]] && ((${#SESSION_HISTORY[@]} % 10 == 0)); then
        save_history
    fi
}

show_history() {
    if [[ ${#SESSION_HISTORY[@]} -eq 0 ]]; then
        echo -e "${COLOR_DIM}No commands in history${COLOR_RESET}"
        return
    fi

    echo -e "${COLOR_INFO}Command History:${COLOR_RESET}"
    local i=1
    for cmd in "${SESSION_HISTORY[@]}"; do
        echo "  $i. $cmd"
        ((i++))
    done
}

clear_screen() {
    clear
    print_welcome
}

# -----------------------
# Welcome Message
# -----------------------
print_welcome() {
    cat <<EOF
${COLOR_PROMPT}╔════════════════════════════════════════════════════════════╗${COLOR_RESET}
${COLOR_PROMPT}║${COLOR_RESET}          ${COLOR_AI}VDE AI Assistant${COLOR_RESET} - Interactive Mode          ${COLOR_PROMPT}║${COLOR_RESET}
${COLOR_PROMPT}║                                                            ║${COLOR_RESET}
${COLOR_PROMPT}║${COLOR_RESET}  Control your Virtual Development Environment    ${COLOR_PROMPT}║${COLOR_RESET}
${COLOR_PROMPT}║${COLOR_RESET}  using natural language commands                 ${COLOR_PROMPT}║${COLOR_RESET}
${COLOR_PROMPT}╚════════════════════════════════════════════════════════════╝${COLOR_RESET}

${COLOR_DIM}AI Mode:${COLOR_RESET}        $([[ "$USE_AI" == "true" ]] && echo -e "${COLOR_SUCCESS}Enabled (LLM-based)${COLOR_RESET}" || echo "Pattern-based")
${COLOR_DIM}Persistent:${COLOR_RESET}     $([[ "$PERSISTENT" == "true" ]] && echo -e "${COLOR_SUCCESS}Enabled${COLOR_RESET}" || echo "Disabled")
${COLOR_DIM}Available VMs:${COLOR_RESET}   $(get_all_vms | wc -l) language(s), $(get_service_vms | wc -l) service(s)

${COLOR_DIM}Keyboard shortcuts:${COLOR_RESET} Ctrl+R=history, Ctrl+L=clear, Ctrl+D=submit, Ctrl+C=exit

${COLOR_DIM}Type 'help' for commands or 'exit' to quit${COLOR_RESET}
EOF
}

# -----------------------
# Prompt Helpers
# -----------------------
show_prompt() {
    echo -e -n "${COLOR_PROMPT}[VDE] → ${COLOR_RESET}"
}

show_ai_response() {
    echo -e "${COLOR_AI}[AI] → ${COLOR_RESET}"
}

show_success() {
    echo -e "${COLOR_SUCCESS}✓${COLOR_RESET} $1"
}

show_error() {
    echo -e "${COLOR_ERROR}✗${COLOR_RESET} $1"
}

# -----------------------
# Command Resolution
# -----------------------
resolve_alias() {
    local cmd="$1"
    local cmd_lower="${cmd:l}"
    
    # Check if it's an alias
    if [[ -n "${CHAT_ALIASES[$cmd_lower]}" ]]; then
        echo "${CHAT_ALIASES[$cmd_lower]}"
    else
        echo "$cmd"
    fi
}

# -----------------------
# Special Commands
# -----------------------
handle_special_command() {
    local cmd="$1"
    local cmd_lower="${cmd:l}"

    case "$cmd_lower" in
        exit|quit|bye)
            echo ""
            echo -e "${COLOR_INFO}Goodbye!${COLOR_RESET}"
            if [[ "$PERSISTENT" == "true" ]]; then
                save_history
                echo -e "${COLOR_DIM}History saved to $FILE_HISTORY${COLOR_RESET}"
            fi
            return 0  # Signal to exit
            ;;
        help|'?'|'help me')
            show_ai_help
            return 1  # Continue
            ;;
        clear|cls)
            clear_screen
            return 1  # Continue
            ;;
        history|h|hist)
            show_history
            return 1  # Continue
            ;;
        '')
            return 1  # Continue (empty input)
            ;;
        *)
            return 2  # Not a special command
            ;;
    esac
}

show_ai_help() {
    cat <<EOF
${COLOR_INFO}Available Commands:${COLOR_RESET}

  VM Management:
    create-virtual-for <type> [name]  Create a new VM
    start-virtual <name>              Start a VM
    shutdown-virtual <name>           Stop a VM
    list-vms                          List all VMs
    ssh <name>                        SSH into a VM

  Natural Language Examples:
    "create a Python VM"
    "start my Python development environment"
    "what's running?"
    "list all VMs"
    "stop the postgres container"

  Chat Commands:
    help, ?           Show this help
    history, h        Show command history
    clear, cls        Clear screen
    quit, exit, bye   Exit chat mode

  Keyboard Shortcuts:
    Ctrl+R            Search history
    Ctrl+L            Clear screen
    Ctrl+D            Submit multi-line input
    Ctrl+C            Cancel/Exit

EOF
}

# -----------------------
# Input Handling
# -----------------------

# Read input with history navigation
read_with_history() {
    local prompt="$1"
    local input=""
    local buffer=""
    local pos=0
    
    # Use zsh's builtin read with history if available
    if [[ -n "$HISTFILE" ]]; then
        read -k "$prompt"
    else
        echo -n "$prompt"
        read -r input
    fi
    
    echo "$input"
}

# -----------------------
# Main Loop
# -----------------------
main_loop() {
    print_welcome

    while true; do
        show_prompt
        
        # Read input (simple read for portability)
        local input=""
        read -r input

        # Handle Ctrl+C (empty input at prompt)
        if [[ -z "$input" ]]; then
            echo ""
            echo -e "${COLOR_DIM}Type 'exit' to quit or press Ctrl+C${COLOR_RESET}"
            continue
        fi

        # Handle special commands
        handle_special_command "$input"
        local status=$?

        case $status in
            0)  # Exit requested
                return 0
                ;;
            1)  # Continue to next iteration
                continue
                ;;
            2)  # Not a special command, process as AI command
                ;;
        esac

        # Resolve aliases
        local resolved_cmd
        resolved_cmd=$(resolve_alias "$input")

        # Add to history
        add_to_history "$input"

        # Process the command
        echo ""

        # Generate plan
        local plan
        if [[ "$USE_AI" == "true" ]] && [[ "$AI_API_AVAILABLE" == "true" ]] && ai_api_available 2>/dev/null; then
            plan=$(parse_command_with_ai "$input" 2>&1)
            local parse_exit_code=$?
            if [[ $parse_exit_code -ne 0 ]]; then
                echo -e "${COLOR_DIM}AI parsing failed, using pattern-based...${COLOR_RESET}"
                plan=$(generate_plan "$input")
            fi
        else
            # Use pattern-based parsing
            plan=$(generate_plan "$input")
        fi

        # Execute plan
        local result
        result=$(echo "$plan" | execute_plan 2>&1)
        local exit_code=$?

        # Format output
        show_ai_response

        if [[ $exit_code -eq 0 ]]; then
            if [[ -n "$result" ]]; then
                # Indent the result for better readability
                echo "$result" | while IFS= read -r line; do
                    if [[ -n "$line" ]]; then
                        echo -e "       ${COLOR_SUCCESS}${line}${COLOR_RESET}"
                    fi
                done
            else
                echo -e "       ${COLOR_SUCCESS}Done!${COLOR_RESET}"
            fi
        else
            echo -e "       ${COLOR_ERROR}Error: $result${COLOR_RESET}"
        fi

        echo ""
    done
}

# -----------------------
# Run
# -----------------------
main_loop
