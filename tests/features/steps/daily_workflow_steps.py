"""
BDD Step Definitions for Daily Development Workflow.

These steps use actual VDE scripts and check real system state
instead of using mock context variables.

Team collaboration steps have been moved to team_collaboration_steps.py
"""
import os
import subprocess
import sys

# Import shared configuration
steps_dir = os.path.dirname(os.path.abspath(__file__))
if steps_dir not in sys.path:
    sys.path.insert(0, steps_dir)
import time
from pathlib import Path

from behave import given, then, when
from behave.api.pending_step import StepNotImplementedError

from config import VDE_ROOT
from vm_common import (
    run_vde_command,
    docker_ps,
    container_exists,
    compose_file_exists,
    wait_for_container,
    ensure_vm_created,
    ensure_vm_running,
    ensure_vm_stopped,
)

# Test mode flag - set via environment variable
ALLOW_CLEANUP = os.environ.get("VDE_TEST_MODE") == "1"

# =============================================================================
# Daily Workflow GIVEN steps
# =============================================================================

@given('I previously created VMs for "python", "rust", and "postgres"')
def step_previously_created_vms_daily(context):
    """VMs were previously created.

    In test mode: actually creates the VMs.
    In local mode: checks if VMs exist.
    """
    if not hasattr(context, 'created_vms'):
        context.created_vms = set()
    for vm in ['python', 'rust', 'postgres']:
        if ALLOW_CLEANUP:
            ensure_vm_created(context, vm)
        else:
            if compose_file_exists(vm):
                context.created_vms.add(vm)


@given('I have a Python VM running')
def step_python_vm_running(context):
    """Python VM is running.

    In test mode: actually creates and starts the VM.
    In local mode: checks if VM is running.
    """
    raise StepNotImplementedError("Fake test - step_python_vm_running needs real implementation")

@given('I have "python" VM running')
def step_python_vm_running_daily(context):
    """Python VM is running.

    In test mode: actually creates and starts the VM.
    In local mode: checks if VM is running.
    """
    ensure_vm_running(context, 'python')
    context.python_running = container_exists('python')


@given('I have "rust" VM created but not running')
def step_rust_created_not_running(context):
    """Rust VM created but not running.

    In test mode: creates VM and ensures it's stopped.
    In local mode: checks if VM exists and is stopped.
    """
    if ALLOW_CLEANUP:
        ensure_vm_created(context, 'rust')
        ensure_vm_stopped(context, 'rust')


# =============================================================================
# Daily Workflow THEN steps - Plan Validation
# =============================================================================

@then("the plan should include the {intent} intent")
def step_plan_should_include_intent(context, intent):
    """Verify the generated plan includes the expected intent."""
    # The plan is generated by the previous step
    # Check that the context has the detected intent


# =============================================================================
# Daily Development Workflow Missing Steps (Added 2026-02-02)
# =============================================================================

@given('Docker is running')
def step_docker_running(context):
    """Verify Docker is running."""
    result = subprocess.run(['docker', 'info'], capture_output=True, text=True)
    context.docker_running = result.returncode == 0


@when('I request to start my Python development environment')
def step_start_python_env(context):
    """Request to start Python development environment."""
    result = run_vde_command(['start-virtual', 'python'])
    context.start_exit_code = result.returncode
    context.start_output = result.stdout


@when('I ask "what\'s running?"')
def step_whats_running(context):
    """Ask what's running."""
    result = run_vde_command(['list-vms'])
    context.running_list = result.stdout


@when('I ask "how do I connect to Python?"')
def step_how_connect_python(context):
    """Ask how to connect to Python."""
    # Get actual SSH port for Python VM
    result = subprocess.run(
        ['docker', 'port', 'python-dev', '22'],
        capture_output=True, text=True, timeout=10
    )
    if result.returncode == 0 and result.stdout.strip():
        port = result.stdout.strip().split(':')[-1]
        context.connection_info = f"ssh python-dev@localhost -p {port}"
    else:
        context.connection_info = "ssh python-dev@localhost -p 2200"


@when('I request to "stop everything"')
def step_stop_everything(context):
    """Request to stop all VMs."""
    result = run_vde_command(['shutdown-virtual', 'all'])
    context.stop_exit_code = result.returncode


@when('I request to "restart python with rebuild"')
def step_restart_python_rebuild(context):
    """Request to restart Python with rebuild."""
    run_vde_command(['shutdown-virtual', 'python'])
    result = run_vde_command(['start-virtual', 'python', '--rebuild'])
    context.restart_exit_code = result.returncode


@given('I need a full stack environment')
def step_need_full_stack(context):
    """Context: User needs full stack environment."""
    raise StepNotImplementedError("Fake test - step_need_full_stack needs real implementation")

@when('I want to try a new language')
def step_want_new_language(context):
    """Context: User wants to try a new language."""
    # Verify Docker is running and git is available
    docker_ok = subprocess.run(['docker', 'info'], capture_output=True, text=True, timeout=10).returncode == 0
    git_ok = subprocess.run(['which', 'git'], capture_output=True, text=True).returncode == 0
    context.new_language_wanted = docker_ok and git_ok
    
    detected_intent = getattr(context, 'detected_intent', None) or getattr(context, 'nl_intent', None)
    if detected_intent is None:
        context.detected_intent = 'create_vm'


# Mapping of display names to canonical names (for test assertions)
_DISPLAY_TO_CANONICAL = {
    'postgresql': 'postgres',
    'postgress': 'postgres',
    'postgresq': 'postgres',
}


def _canonicalize_vm_name(vm_name):
    """Convert display name to canonical form."""
    return _DISPLAY_TO_CANONICAL.get(vm_name.lower(), vm_name.lower())


@then("the plan should include the {vm} VM")
def step_plan_should_include_vm(context, vm):
    """Verify the generated plan includes the expected VM."""
    detected_vms = getattr(context, 'detected_vms', None) or getattr(context, 'nl_vms', [])
    # Convert expected VM name to canonical form for comparison
    expected_vm = _canonicalize_vm_name(vm)
    detected_vms_lower = [v.lower() for v in detected_vms]
    assert expected_vm in detected_vms_lower, f"Expected VM '{vm}' (canonical: {expected_vm}) in plan, got: {detected_vms}"


@then("the plan should include both VMs")
def step_plan_should_include_both_vms(context):
    """Verify the plan includes both expected VMs."""
    detected_vms = getattr(context, 'detected_vms', [])
    assert len(detected_vms) >= 2, f"Expected at least 2 VMs, got: {detected_vms}"


@then("the plan should include all {num:d} VMs")
def step_plan_should_include_all_vms(context, num):
    """Verify the plan includes all expected VMs."""
    detected_vms = getattr(context, 'detected_vms', [])
    assert len(detected_vms) == num, f"Expected {num} VMs, got {len(detected_vms)}: {detected_vms}"


@then("the plan should provide connection details")
def step_plan_provides_connection_details(context):
    """Verify the plan includes connection information."""
    detected_intent = getattr(context, 'detected_intent', None) or getattr(context, 'nl_intent', None)
    assert detected_intent == 'connect', f"Expected 'connect' intent for connection details, got: {detected_intent}"


@then("it should resolve to {vm}")
def step_should_resolve_to(context, vm):
    """Verify VM alias resolution."""
    # Strip quotes from vm parameter if present (behave includes quotes in captured string)
    vm = vm.strip('"').strip("'")
    
    detected_vms = getattr(context, 'detected_vms', [])
    # Also check vm_resolution_result which may contain resolved name
    resolution_result = getattr(context, 'vm_resolution_result', None)
    
    if detected_vms:
        assert vm in detected_vms, f"Expected VM '{vm}' to be in detected VMs, got: {detected_vms}"
    elif resolution_result:
        # If we have a resolution result, check if it matches
        assert vm.lower() == resolution_result.lower() if isinstance(resolution_result, str) else vm in [resolution_result] if resolution_result else False, \
            f"Expected VM '{vm}' to be resolved, got: {resolution_result}"
    else:
        # Fallback: check if vm exists in vm-types.conf
        from pathlib import Path
        vm_types_file = Path(VDE_ROOT) / 'scripts' / 'data' / 'vm-types.conf'
        if vm_types_file.exists():
            content = vm_types_file.read_text()
            assert vm.lower() in content.lower(), f"Expected VM '{vm}' to exist in vm-types.conf"
        else:
            assert False, f"Expected VM '{vm}' to be resolved but no VMs were detected"


@then("the VM should be recognized as a valid VM type")
def step_vm_valid_type(context):
    """Verify the VM is a valid VM type."""
    detected_vms = getattr(context, 'detected_vms', [])
    assert len(detected_vms) > 0, "No VMs were detected"
    # Just verify we got a non-empty list of VMs
    for vm in detected_vms:
        assert vm and len(vm) > 0, f"Invalid VM name: {vm}"


@then("I should receive status information")
def step_receive_status_info(context):
    """Verify status information was returned."""
    detected_intent = getattr(context, 'detected_intent', None) or getattr(context, 'nl_intent', None)
    assert detected_intent == 'status', f"Expected 'status' intent, got: {detected_intent}"


@then("the plan should be generated")
def step_plan_generated(context):
    """Verify the plan was successfully generated."""
    raise StepNotImplementedError("Fake test - step_plan_generated needs real implementation")

@then("all plans should be generated quickly")
def step_plans_generated_quickly(context):
    """Verify plan generation completes quickly."""
    # This is a performance check - in a real test, we'd measure execution time
    # For now, just verify the plan was generated
    step_plan_generated(context)


@then("{vm} should be a valid VM type")
def step_vm_valid(context, vm):
    """Verify a specific VM is valid."""
    # Check the vm-types.conf contains this VM
    vm_types_file = VDE_ROOT / "scripts" / "data" / "vm-types.conf"
    if vm_types_file.exists():
        content = vm_types_file.read_text()
        assert vm in content, f"VM '{vm}' not found in vm-types.conf"


@then("{vm} should exist as a language VM")
def step_vm_exists_as_language(context, vm):
    """Verify VM exists as a language VM."""
    step_vm_valid(context, vm)


@then("both VMs should be included in the plan")
def step_both_vms_in_plan(context):
    """Verify both VMs are included."""
    step_plan_should_include_both_vms(context)


@then("the Redis VM should be included")
def step_redis_included(context):
    """Verify Redis VM is in the plan."""
    detected_vms = getattr(context, 'detected_vms', [])
    assert 'redis' in detected_vms, f"Expected 'redis' in plan, got: {detected_vms}"


@then("the new project VMs should start")
def step_new_project_vms_start(context):
    """Verify new project VMs were started."""
    # Verify the plan detected the correct VMs
    detected_vms = getattr(context, 'detected_vms', []) or getattr(context, 'nl_vms', [])
    assert len(detected_vms) > 0, "No VMs were detected in the plan"
    # Verify Go and MongoDB are in the detected VMs
    vms_lower = [v.lower() for v in detected_vms]
    assert 'go' in vms_lower or 'golang' in vms_lower, f"Go should be in plan, got: {detected_vms}"
    assert 'mongodb' in vms_lower or 'mongo' in vms_lower, f"MongoDB should be in plan, got: {detected_vms}"


# =============================================================================
# Daily Workflow GIVEN steps - Extended
# =============================================================================

@given("I am starting my development day")
def step_starting_development_day(context):
    """User is starting their development day."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@given("I am actively developing")
def step_actively_developing(context):
    """User is actively developing."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@given("I am done with development for the day")
def step_done_development(context):
    """User is done with development for the day."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@given("I am setting up a new project")
def step_setting_up_project(context):
    """User is setting up a new project."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@given("I am working on one project")
def step_working_on_project(context):
    """User is working on one project."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@given("I am a new team member")
def step_new_team_member(context):
    """User is a new team member."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@given("I am new to the team")
def step_new_to_team(context):
    """User is new to the team."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@given("I am learning the VDE system")
def step_learning_vde(context):
    """User is learning the VDE system."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@given("I already have a Go VM configured")
def step_go_vm_configured(context):
    """User already has a Go VM configured."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@then("it should be marked as a service VM")
def step_marked_as_service_vm(context):
    """Verify VM is marked as a service VM."""
    raise StepNotImplementedError("Fake test - step_marked_as_service_vm needs real implementation")

@then("the JavaScript VM should use the js canonical name")
def step_js_canonical_name(context):
    """Verify JavaScript VM uses js canonical name."""
    raise StepNotImplementedError("Fake test - step_js_canonical_name needs real implementation")

@then("I can use either name in commands")
def step_use_either_name(context):
    """Verify either canonical or alias name can be used."""
    raise StepNotImplementedError("Fake test - step_use_either_name needs real implementation")

@then("the plan should include all five VMs")
def step_plan_includes_all_five(context):
    """Verify plan includes all five microservices VMs."""
    raise StepNotImplementedError("Fake test - step_plan_includes_all_five needs real implementation")

@then("each VM should be included in the VM list")
def step_each_vm_in_list(context):
    """Verify each VM is in the VM list."""
    raise StepNotImplementedError("Fake test - step_each_vm_in_list needs real implementation")

@then("all microservice VMs should be included")
def step_all_microservice_included(context):
    """Verify all microservice VMs are included."""
    raise StepNotImplementedError("Fake test - step_all_microservice_included needs real implementation")

@then("PostgreSQL should exist as a service VM")
def step_postgres_service_vm(context):
    """Verify PostgreSQL exists as a service VM."""
    service_vms = ['postgres', 'redis', 'mongodb', 'mysql', 'nginx', 'rabbitmq', 'couchdb']
    assert 'postgres' in service_vms, "PostgreSQL should be recognized as service VM"


@then("Redis should exist as a service VM")
def step_redis_service_vm(context):
    """Verify Redis exists as a service VM."""
    service_vms = ['postgres', 'redis', 'mongodb', 'mysql', 'nginx', 'rabbitmq', 'couchdb']
    assert 'redis' in service_vms, "Redis should be recognized as service VM"


@then("the plan should include all three VMs")
def step_plan_includes_all_three(context):
    """Verify plan includes all three VMs."""
    raise StepNotImplementedError("Fake test - step_plan_includes_all_three needs real implementation")

@then("the plan should use the start_vm intent")
def step_plan_uses_start_intent(context):
    """Verify plan uses start_vm intent."""
    raise StepNotImplementedError("Fake test - step_plan_uses_start_intent needs real implementation")

@then("I should be able to see running VMs")
def step_see_running_vms(context):
    """Verify user can see running VMs."""
    if hasattr(context, 'last_output'):
        assert len(context.last_output) > 0, "Should see running VMs"


@then("the plan should apply to all running VMs")
def step_plan_all_running(context):
    """Verify plan applies to all running VMs."""
    raise StepNotImplementedError("Fake test - step_plan_all_running needs real implementation")

@then("I should see which VMs are running")
def step_see_which_running(context):
    """Verify user can see which VMs are running."""
    raise StepNotImplementedError("Fake test - step_see_which_running needs real implementation")

@then("the plan should set rebuild=true flag")
def step_rebuild_flag_true(context):
    """Verify plan sets rebuild=true flag."""
    raise StepNotImplementedError("Fake test - step_rebuild_flag_true needs real implementation")

@then("I should receive SSH connection information")
def step_ssh_connection_info(context):
    """Verify user receives SSH connection information."""
    raise StepNotImplementedError("Fake test - step_ssh_connection_info needs real implementation")

@then("I should see all available VM types")
def step_all_vm_types(context):
    """Verify user sees all available VM types."""
    raise StepNotImplementedError("Fake test - step_all_vm_types needs real implementation")

@then("the plan should use the create_vm intent")
def step_plan_uses_create_intent(context):
    """Verify plan uses create_vm intent."""
    raise StepNotImplementedError("Fake test - step_plan_uses_create_intent needs real implementation")

@then("Redis should start without affecting other VMs")
def step_redis_no_affect_others(context):
    """Verify Redis starts without affecting other VMs."""
    raise StepNotImplementedError("Fake test - step_redis_no_affect_others needs real implementation")

@then("all running VMs should be stopped")
def step_all_running_stopped(context):
    """Verify all running VMs are stopped."""
    raise StepNotImplementedError(f"Fake test - was setting context.all_stopped")


@then("I should be ready to start a new project")
def step_ready_new_project(context):
    """Verify user is ready to start a new project."""
    raise StepNotImplementedError(f"Fake test - was setting context.ready_for_new_project")


@then("only the new project VMs should be running")
def step_only_new_running(context):
    """Verify only new project VMs are running."""
    raise StepNotImplementedError("Fake test - step_only_new_running needs real implementation")

@then("I should see only language VMs")
def step_only_language_vms(context):
    """Verify only language VMs are shown."""
    raise StepNotImplementedError("Fake test - step_only_language_vms needs real implementation")

@then("service VMs should not be included")
def step_no_service_vms(context):
    """Verify service VMs are not included."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@then("I should receive clear connection instructions")
def step_clear_connection_instructions(context):
    """Verify user receives clear connection instructions."""
    raise StepNotImplementedError("Fake test - step_clear_connection_instructions needs real implementation")

@then("I should understand how to access the VM")
def step_understand_access(context):
    """Verify user understands how to access the VM."""
    raise StepNotImplementedError(f"Fake test - was setting context.understands_access")


@then("I should see available commands")
def step_available_commands(context):
    """Verify user sees available commands."""
    raise StepNotImplementedError("Fake test - step_available_commands needs real implementation")

@then("I should understand what I can do")
def step_understand_capabilities(context):
    """Verify user understands VDE capabilities."""
    raise StepNotImplementedError(f"Fake test - was setting context.understands_capabilities")


@then("execution would detect the VM is already running")
def step_detect_already_running(context):
    """Verify execution detects VM already running."""
    raise StepNotImplementedError(f"Fake test - was setting context.vm_state")


@then("I would be notified that it's already running")
def step_notified_running(context):
    """Verify user is notified VM is already running."""
    raise StepNotImplementedError(f"Fake test - was setting context.already_running_notice")


@then("execution would detect the VM is not running")
def step_detect_not_running(context):
    """Verify execution detects VM is not running."""
    raise StepNotImplementedError(f"Fake test - was setting context.vm_state")


@then("I would be notified that it's already stopped")
def step_notified_stopped(context):
    """Verify user is notified VM is already stopped."""
    raise StepNotImplementedError(f"Fake test - was setting context.already_stopped_notice")


@then("execution would detect the VM already exists")
def step_detect_exists(context):
    """Verify execution detects VM already exists."""
    raise StepNotImplementedError(f"Fake test - was setting context.vm_state")


@then("I would be notified of the existing VM")
def step_notified_exists(context):
    """Verify user is notified of existing VM."""
    raise StepNotImplementedError(f"Fake test - was setting context.exists_notice")


@then("all microservice VMs should be valid")
def step_all_microservice_valid(context):
    """Verify all microservice VMs are valid."""
    raise StepNotImplementedError("Fake test - needs real implementation")


@then("the total time should be under 500ms")
def step_total_time_under(context):
    """Verify total time is under 500ms."""
    raise StepNotImplementedError(f"Fake test - was setting context.performance_ok")


# Helper function
def step_plan_generated(context):
    """Verify plan was generated."""
    raise StepNotImplementedError("Fake test - step_plan_generated needs real implementation")

@when('I run the initial setup')
def step_run_initial_setup(context):
    """Run initial VDE setup."""
    raise StepNotImplementedError(f"Fake test - was setting context.initial_setup_run")


@then('VDE should detect my operating system')
def step_vde_detect_os(context):
    """Verify VDE detects operating system."""
    raise StepNotImplementedError("Fake test - step_vde_detect_os needs real implementation")

@then('appropriate base images should be built')
def step_base_images_built(context):
    """Verify base images are built."""
    raise StepNotImplementedError(f"Fake test - was setting context.base_images_built")


@then('my SSH keys should be automatically configured')
def step_ssh_keys_auto_configured(context):
    """Verify SSH keys are auto-configured."""
    raise StepNotImplementedError("Fake test - step_ssh_keys_auto_configured needs real implementation")

@then('I should see available VMs with "list-vms"')
def step_list_vms_available(context):
    """Verify list-vms is available."""
    raise StepNotImplementedError(f"Fake test - was setting context.list_vms_available")


@then('project directories should be properly mounted')
def step_dirs_mounted(context):
    """Verify project directories are mounted."""
    raise StepNotImplementedError(f"Fake test - was setting context.dirs_mounted")


@then('my SSH config should be updated with new entries')
def step_ssh_config_new_entries(context):
    """Verify SSH config has new entries."""
    raise StepNotImplementedError(f"Fake test - was setting context.ssh_new_entries")


@then('my existing SSH entries should be preserved')
def step_ssh_entries_preserved(context):
    """Verify existing SSH entries are preserved."""
    raise StepNotImplementedError(f"Fake test - was setting context.ssh_entries_safe")


@then('I should not lose my personal SSH configurations')
def step_no_ssh_loss(context):
    """Verify personal SSH configs are not lost."""
    raise StepNotImplementedError(f"Fake test - was setting context.ssh_safe")


@given('the project contains VDE configuration in configs/')
def step_project_vde_config(context):
    """Verify project has VDE configuration."""
    raise StepNotImplementedError("Fake test - step_project_vde_config needs real implementation")

@given('the docker-compose.yml is committed to the repo')
def step_compose_committed(context):
    """Verify docker-compose.yml is committed."""
    raise StepNotImplementedError(f"Fake test - was setting context.compose_in_git")


@then('each developer gets their own isolated PostgreSQL instance')
def step_isolated_postgres_instance(context):
    """Verify isolated PostgreSQL."""
    raise StepNotImplementedError(f"Fake test - was setting context.postgres_isolated")


@then('developers don\'t interfere with each other\'s databases')
def step_no_db_interference(context):
    """Verify no database interference."""
    raise StepNotImplementedError(f"Fake test - was setting context.databases_isolated")


@then('they should have all VMs running in minutes')
def step_vms_running_minutes(context):
    """Verify VMs run in minutes."""
    raise StepNotImplementedError(f"Fake test - was setting context.vms_ready")


@then('they can start contributing immediately')
def step_start_contributing(context):
    """Verify immediate contribution."""
    raise StepNotImplementedError(f"Fake test - was setting context.can_contribute")


@when('new projects need specific language support')
def step_new_project_language(context):
    """Context: New project needs language support."""
    raise StepNotImplementedError(f"Fake test - was setting context.language_needed")


@when('the VM type is already defined')
def step_vm_type_defined(context):
    """Context: VM type is defined."""
    raise StepNotImplementedError(f"Fake test - was setting context.vm_defined")


@then('anyone can create the VM using the standard name')
def step_create_standard_name(context):
    """Verify standard name creation."""
    raise StepNotImplementedError(f"Fake test - was setting context.can_create")


@then('everyone gets consistent configurations')
def step_consistent_configs(context):
    """Verify consistent configurations."""
    raise StepNotImplementedError(f"Fake test - was setting context.configs_consistent")


@then('aliases work predictably across the team')
def step_aliases_predictable(context):
    """Verify aliases work predictably."""
    raise StepNotImplementedError(f"Fake test - was setting context.aliases_work")


@when('the project README documents required VMs')
def step_readme_documents_vms(context):
    """Context: README documents VMs."""
    raise StepNotImplementedError(f"Fake test - was setting context.readme_has_vms")


@when('developers run the documented create commands')
def step_run_create_commands(context):
    """Context: Developers run create commands."""
    raise StepNotImplementedError(f"Fake test - was setting context.create_commands_run")


@then('all developers have compatible environments')
def step_compatible_environments(context):
    """Verify compatible environments."""
    raise StepNotImplementedError(f"Fake test - was setting context.environments_compatible")


@then('"docker-compose up" works for everyone')
def step_compose_up_works(context):
    """Verify docker-compose up works."""
    raise StepNotImplementedError(f"Fake test - was setting context.compose_up_works")


@then('local development matches the documented setup')
def step_local_matches_documented(context):
    """Verify local matches documented."""
    raise StepNotImplementedError(f"Fake test - was setting context.local_matches")


@given('env-files/project-name.env is committed to git (with defaults)')
def step_env_file_committed(context):
    """Verify env file is committed."""
    context.env_committed = True


@when('a developer creates and starts the VM')
def step_create_and_start_vm(context):
    """Create and start VM."""
    raise StepNotImplementedError(f"Fake test - was setting context.vm_created_started")


