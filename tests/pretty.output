Feature: Productivity Features for Developers # features/productivity-features.feature:2
  As a developer
  I want shortcuts and automation for common tasks
  So that I can focus on coding instead of environment management
  Scenario: One command to start entire project stack       # features/productivity-features.feature:7
    Given my project needs python, postgres, and redis      # features/steps/parser_steps.py:1565
    When I run "start-virtual python postgres redis"        # features/steps/vm_lifecycle_steps.py:292
    Then all three VMs should start with one command        # features/steps/parser_steps.py:1570
    And I don't need to remember separate commands for each # features/steps/parser_steps.py:1575

  Scenario: Start all my project VMs by name       # features/productivity-features.feature:13
    Given I have 5 VMs configured for my project   # features/steps/pattern_steps.py:125
    When I run "start-virtual all"                 # features/steps/daily_workflow_steps.py:313
    Then all my created VMs should start           # features/steps/parser_steps.py:1580
    And I don't need to list each one individually # features/steps/parser_steps.py:1585

  Scenario: Quick access to my projects via SSH        # features/productivity-features.feature:19
    Given I have VMs running for my project            # features/steps/parser_steps.py:1594
    When I run "ssh python-dev"                        # features/steps/ssh_steps.py:3052
    Then I should be connected immediately             # features/steps/parser_steps.py:1599
    And I don't need to remember ports or IP addresses # features/steps/parser_steps.py:1604
    And SSH agent forwarding is automatic              # features/steps/parser_steps.py:1609

  Scenario: Access code from host editor                  # features/productivity-features.feature:26
    Given my VM is running with volume mounts             # features/steps/parser_steps.py:1614
    When I edit files in projects/<lang>/ on my host      # features/steps/parser_steps.py:1619
    Then changes are immediately visible in the VM        # features/steps/parser_steps.py:1624
    And I can use my preferred editor (VSCode, vim, etc.) # features/steps/parser_steps.py:1629
    And I don't need to edit files inside the container   # features/steps/parser_steps.py:1634

  Scenario: Run commands on host from within VM  # features/productivity-features.feature:33
    Given I'm working inside a VM                # features/steps/parser_steps.py:1639
    When I want to run a command on my host      # features/steps/parser_steps.py:1644
    Then I can use the host communication tools  # features/steps/parser_steps.py:1649
    And I don't need to exit the VM              # features/steps/parser_steps.py:1654

  Scenario: Share a single PostgreSQL across projects      # features/productivity-features.feature:39
    Given I have multiple projects using PostgreSQL        # features/steps/parser_steps.py:1663
    When I start one postgres VM                           # features/steps/parser_steps.py:1668
    And I start multiple language VMs                      # features/steps/parser_steps.py:1675
    Then all language VMs can connect to the same postgres # features/steps/parser_steps.py:1680
    And I don't need separate databases for each project   # features/steps/parser_steps.py:1685

  Scenario: Use my host's Git credentials from VM        # features/productivity-features.feature:46
    Given I'm working inside a VM                        # features/steps/parser_steps.py:1639
    When I need to git push to GitHub                    # features/steps/parser_steps.py:1694
    Then SSH agent forwarding gives me access to my keys # features/steps/parser_steps.py:1699
    And I don't need to copy keys into the container     # features/steps/parser_steps.py:1704
    And I can push without entering passwords            # features/steps/parser_steps.py:1709

  Scenario: Persistent data survives container restart  # features/productivity-features.feature:53
    Given I have data in postgres                       # features/steps/productivity_steps.py:252
    When I stop and restart postgres VM                 # features/steps/productivity_steps.py:450
    Then my data should still be there                  # features/steps/productivity_steps.py:636
    And I don't lose work between sessions              # features/steps/productivity_steps.py:808

  Scenario: Quick project switching                         # features/productivity-features.feature:59
    Given I'm working on a Python project                   # features/steps/productivity_steps.py:257
    When I want to switch to a Rust project                 # features/steps/productivity_steps.py:455
    And I run "ssh rust-dev"                                # features/steps/vm_lifecycle_steps.py:292
    Then I'm immediately in the Rust environment            # features/steps/productivity_steps.py:641
    And I don't need to change terminal or context manually # features/steps/productivity_steps.py:813

  Scenario: Consistent tool versions across team      # features/productivity-features.feature:66
    Given my project requires specific Node version   # features/steps/productivity_steps.py:262
    When the team defines the JS VM with that version # features/steps/productivity_steps.py:460
    Then everyone gets the same Node version          # features/steps/productivity_steps.py:646
    And "works on my machine" problems are reduced    # features/steps/productivity_steps.py:818

  Scenario: Develop with database like in production          # features/productivity-features.feature:72
    Given production uses PostgreSQL with specific extensions # features/steps/productivity_steps.py:267
    When I configure the postgres VM with those extensions    # features/steps/productivity_steps.py:465
    Then my local database matches production                 # features/steps/productivity_steps.py:651
    And I catch compatibility issues early                    # features/steps/productivity_steps.py:823

  Scenario: Run services in background while I work  # features/productivity-features.feature:78
    Given I need postgres and redis running          # features/steps/productivity_steps.py:272
    When I start them as service VMs                 # features/steps/productivity_steps.py:470
    Then they run in background                      # features/steps/productivity_steps.py:656
    And I can focus on my application VM             # features/steps/productivity_steps.py:828
    And they stay running across coding sessions     # features/steps/productivity_steps.py:833

  Scenario: Test with clean state quickly    # features/productivity-features.feature:85
    Given I need to test with fresh database # features/steps/productivity_steps.py:277
    When I stop and remove postgres          # features/steps/productivity_steps.py:475
    And I recreate and start it              # features/steps/productivity_steps.py:480
    Then I get a fresh database instantly    # features/steps/productivity_steps.py:661
    And I don't need to manually clean data  # features/steps/productivity_steps.py:838

  Scenario: Develop offline if needed       # features/productivity-features.feature:92
    Given I'm working without internet      # features/steps/productivity_steps.py:282
    When my Docker images are already built # features/steps/ssh_docker_steps.py:325
    Then I can start and use VMs offline    # features/steps/productivity_steps.py:666
    And I'm not blocked by network issues   # features/steps/productivity_steps.py:843

  Scenario: Extend VM with custom packages         # features/productivity-features.feature:98
    Given I need additional tools in my Python VM  # features/steps/productivity_steps.py:287
    When I modify the Dockerfile to add packages   # features/steps/productivity_steps.py:488
    And I rebuild with --rebuild                   # features/steps/productivity_steps.py:493
    Then the packages are available in the VM      # features/steps/productivity_steps.py:675
    And I don't need to manually install each time # features/steps/productivity_steps.py:848

  Scenario: View all running VMs at a glance  # features/productivity-features.feature:105
    Given I have multiple VMs running         # features/steps/pattern_steps.py:117
    When I run "docker ps"                    # features/steps/vm_lifecycle_steps.py:292
    Then I can see all my VDE containers      # features/steps/ssh_docker_steps.py:343
    And I can verify what's currently active  # features/steps/productivity_steps.py:853

  Scenario: Clean stop of all VMs      # features/productivity-features.feature:111
    Given I'm done working for the day # features/steps/productivity_steps.py:292
    When I run "shutdown-virtual all"  # features/steps/daily_workflow_steps.py:323
    Then all VMs stop gracefully       # features/steps/productivity_steps.py:680
    And no orphaned containers remain  # features/steps/productivity_steps.py:858
    And my system is clean             # features/steps/productivity_steps.py:863

  Scenario: Development environment survives reboot  # features/productivity-features.feature:118
    Given I've configured my VMs                     # features/steps/productivity_steps.py:297
    When I restart my computer                       # features/steps/productivity_steps.py:498
    And I run "start-virtual all" again              # features/steps/productivity_steps.py:1114
    Then all my VMs start with saved configuration   # features/steps/productivity_steps.py:685
    And I don't need to reconfigure anything         # features/steps/productivity_steps.py:868

  Scenario: Run tests in isolated environment                # features/productivity-features.feature:125
    Given I need to run tests that might modify system state # features/steps/productivity_steps.py:302
    When I run tests inside a VM                             # features/steps/productivity_steps.py:503
    Then my host system is not affected                      # features/steps/productivity_steps.py:690
    And I can run destructive tests safely                   # features/steps/productivity_steps.py:873
    And I can discard and recreate VM if needed              # features/steps/productivity_steps.py:878

  Scenario: Hot reload during development             # features/productivity-features.feature:132
    Given I'm developing a web application            # features/steps/productivity_steps.py:307
    And I have a watcher/reloader configured          # features/steps/productivity_steps.py:312
    When I edit code in my editor on host             # features/steps/productivity_steps.py:508
    Then the application inside VM detects the change # features/steps/productivity_steps.py:695
    And it hot-reloads automatically                  # features/steps/productivity_steps.py:883
    And I see changes without manual restart          # features/steps/productivity_steps.py:888

  Scenario: Debug across multiple services                                  # features/productivity-features.feature:140
    Given I have a web app (python), database (postgres), and cache (redis) # features/steps/cache_steps.py:365
    When I need to debug an issue                                           # features/steps/productivity_steps.py:513
    Then I can SSH into each service independently                          # features/steps/productivity_steps.py:700
    And I can check logs for each service                                   # features/steps/productivity_steps.py:893
    And I can trace requests across services                                # features/steps/productivity_steps.py:898

  Scenario: Development database with seed data           # features/productivity-features.feature:147
    Given I need realistic data for development           # features/steps/productivity_steps.py:317
    When I create a seed script and run it in postgres VM # features/steps/productivity_steps.py:518
    Then the data persists across VM restarts             # features/steps/productivity_steps.py:705
    And I always have a fresh starting point              # features/steps/productivity_steps.py:903
    And I can reset data when needed                      # features/steps/productivity_steps.py:908

  Scenario: Multiple Node.js versions side by side  # features/productivity-features.feature:154
    Given project A needs Node 16                   # features/steps/productivity_steps.py:322
    And project B needs Node 18                     # features/steps/productivity_steps.py:328
    When I create js-node16 VM and js-node18 VM     # features/steps/productivity_steps.py:523
    Then each VM has its own Node version           # features/steps/productivity_steps.py:710
    And I can work on both projects simultaneously  # features/steps/productivity_steps.py:913
    And versions don't conflict                     # features/steps/productivity_steps.py:918

  Scenario: Parallel development on microservices              # features/productivity-features.feature:162
    Given I'm working on a microservices architecture          # features/steps/productivity_steps.py:334
    When I start all service VMs (auth, api, worker, frontend) # features/steps/productivity_steps.py:530
    Then all services can run simultaneously                   # features/steps/productivity_steps.py:715
    And they can communicate via internal network              # features/steps/productivity_steps.py:923
    And I can test the entire system locally                   # features/steps/productivity_steps.py:928

  Scenario: Quick prototyping with new language      # features/productivity-features.feature:169
    Given I want to try out a new language           # features/steps/productivity_steps.py:339
    When I create a VM for that language             # features/steps/productivity_steps.py:535
    Then I can experiment immediately                # features/steps/productivity_steps.py:720
    And I can delete the VM if I don't want it       # features/steps/productivity_steps.py:933
    And my main development environment is untouched # features/steps/productivity_steps.py:938

  Scenario: Pair programming with shared VM            # features/productivity-features.feature:176
    Given I'm pairing with a colleague                 # features/steps/productivity_steps.py:344
    When we both SSH into the same VM                  # features/steps/productivity_steps.py:540
    Then we can work on the same code                  # features/steps/productivity_steps.py:725
    And we can see each other's changes                # features/steps/productivity_steps.py:943
    And we can use tmux or similar for shared terminal # features/steps/productivity_steps.py:948

  Scenario: VSCode Remote-SSH development                       # features/productivity-features.feature:183
    Given I have VMs running                                    # features/steps/productivity_steps.py:349
    When I open VSCode and connect to python-dev via Remote-SSH # features/steps/productivity_steps.py:545
    Then I get full IDE experience inside the VM                # features/steps/productivity_steps.py:730
    And I can use VSCode extensions for Python                  # features/steps/productivity_steps.py:953
    And I can debug directly from my editor                     # features/steps/productivity_steps.py:958

  Scenario: Run background workers in dedicated VM  # features/productivity-features.feature:190
    Given my app has background job processing      # features/steps/productivity_steps.py:355
    When I create a dedicated worker VM             # features/steps/productivity_steps.py:550
    Then worker runs independently of web VM        # features/steps/productivity_steps.py:735
    And I can scale workers separately              # features/steps/productivity_steps.py:963
    And I can restart worker without affecting web  # features/steps/productivity_steps.py:968

  Scenario: Development SSL/TLS setup                   # features/productivity-features.feature:197
    Given I need to test HTTPS locally                  # features/steps/productivity_steps.py:360
    When I configure nginx VM with SSL                  # features/steps/productivity_steps.py:555
    Then I can access my app over HTTPS locally         # features/steps/productivity_steps.py:740
    And certificates can be self-signed for development # features/steps/productivity_steps.py:973
    And browser warnings are expected but acceptable    # features/steps/productivity_steps.py:978

  Scenario: Database migrations across environments  # features/productivity-features.feature:204
    Given I have migration scripts                   # features/steps/productivity_steps.py:365
    When I run migrations in development VM          # features/steps/productivity_steps.py:560
    Then I can test migrations safely                # features/steps/productivity_steps.py:745
    And I can verify schema changes work             # features/steps/productivity_steps.py:983
    And production database is not affected          # features/steps/productivity_steps.py:988

  Scenario: API mocking and stubbing                       # features/productivity-features.feature:211
    Given I'm developing a client that calls external APIs # features/steps/productivity_steps.py:370
    When I create a mock service VM                        # features/steps/productivity_steps.py:565
    Then I can mock API responses                          # features/steps/productivity_steps.py:750
    And I can test error conditions                        # features/steps/debugging_steps.py:249
    And I don't need to hit real external services         # features/steps/productivity_steps.py:996

  Scenario: Log aggregation for debugging         # features/productivity-features.feature:218
    Given multiple VMs generate logs              # features/steps/productivity_steps.py:375
    When I check logs for each VM                 # features/steps/productivity_steps.py:570
    Then I can view logs from docker logs command # features/steps/ssh_docker_steps.py:349
    And I can check logs/<vm>/ directories        # features/steps/productivity_steps.py:1001
    And I can trace issues across services        # features/steps/productivity_steps.py:1006

  Scenario: File watching and rebuilds          # features/productivity-features.feature:225
    Given I'm compiling code inside VM          # features/steps/productivity_steps.py:380
    When source files change on host            # features/steps/productivity_steps.py:575
    Then the VM sees the changes immediately    # features/steps/productivity_steps.py:758
    And my build tool can rebuild automatically # features/steps/productivity_steps.py:1011
    And I don't need to manually trigger builds # features/steps/productivity_steps.py:1016

  Scenario: Database backups and restores      # features/productivity-features.feature:232
    Given I have important data in postgres VM # features/steps/productivity_steps.py:385
    When I create a backup of data/postgres/   # features/steps/productivity_steps.py:580
    Then I can restore from backup later       # features/steps/productivity_steps.py:763
    And I can migrate data to another machine  # features/steps/productivity_steps.py:1021
    And my work is safely backed up            # features/steps/productivity_steps.py:1026

  Scenario: Performance testing with realistic load  # features/productivity-features.feature:239
    Given I need to test performance                 # features/steps/productivity_steps.py:390
    When I start multiple instances of my service VM # features/steps/productivity_steps.py:585
    Then I can generate realistic load               # features/steps/productivity_steps.py:768
    And I can identify bottlenecks                   # features/steps/productivity_steps.py:1031
    And I don't need external infrastructure         # features/steps/productivity_steps.py:1036

  Scenario: Development vs production configuration        # features/productivity-features.feature:246
    Given I have different settings for dev and production # features/steps/productivity_steps.py:395
    When I use environment variables                       # features/steps/customization_steps.py:467
    Then development uses dev settings                     # features/steps/productivity_steps.py:773
    And production VM can use production settings          # features/steps/productivity_steps.py:1041
    And I don't mix up configurations                      # features/steps/productivity_steps.py:1046

  Scenario: Clean workspace for each project          # features/productivity-features.feature:253
    Given I work on multiple unrelated projects       # features/steps/productivity_steps.py:400
    When each project has its own VM                  # features/steps/productivity_steps.py:593
    Then dependencies don't conflict between projects # features/steps/productivity_steps.py:778
    And I can switch contexts cleanly                 # features/steps/productivity_steps.py:1051
    And each project has isolated workspace           # features/steps/productivity_steps.py:1056

  Scenario: Automated testing workflow      # features/productivity-features.feature:260
    Given I have a comprehensive test suite # features/steps/productivity_steps.py:405
    When I push code changes                # features/steps/productivity_steps.py:598
    Then CI runs tests in similar VMs       # features/steps/productivity_steps.py:783
    And local test results match CI results # features/steps/productivity_steps.py:1061
    And I catch issues before pushing       # features/steps/productivity_steps.py:1066

  Scenario: Quick code review setup           # features/productivity-features.feature:267
    Given a colleague wants to review my code # features/steps/productivity_steps.py:410
    When I share the repository               # features/steps/productivity_steps.py:603
    And they create the same VMs I have       # features/steps/productivity_steps.py:608
    Then they can run my code immediately     # features/steps/productivity_steps.py:788
    And they see the same environment I do    # features/steps/productivity_steps.py:1071
    And review process is faster              # features/steps/productivity_steps.py:1076

  Scenario: Development secrets management          # features/productivity-features.feature:275
    Given my app needs API keys and secrets         # features/steps/productivity_steps.py:415
    When I use env-files for secrets                # features/steps/productivity_steps.py:613
    Then secrets are not committed to git           # features/steps/productivity_steps.py:1081
    And each developer has their own env file       # features/steps/customization_steps.py:509
    And production secrets are never in development # features/steps/productivity_steps.py:1089

  Scenario: Weekend project - quick start Monday  # features/productivity-features.feature:282
    Given I worked on a project Friday            # features/steps/productivity_steps.py:420
    When I come back Monday                       # features/steps/productivity_steps.py:618
    And I run "start-virtual all"                 # features/steps/daily_workflow_steps.py:313
    Then my entire environment is ready           # features/steps/productivity_steps.py:793
    And I can continue exactly where I left off   # features/steps/productivity_steps.py:1094
    And no setup is needed                        # features/steps/productivity_steps.py:1099

  Scenario: Learning a new framework with sandbox  # features/productivity-features.feature:290
    Given I want to learn Django/FastAPI/etc.      # features/steps/productivity_steps.py:425
    When I create a dedicated VM for learning      # features/steps/productivity_steps.py:623
    Then I can experiment freely                   # features/steps/productivity_steps.py:798
    And I can break things without consequences    # features/steps/productivity_steps.py:1104
    And I can delete the VM when done learning     # features/steps/productivity_steps.py:1109

