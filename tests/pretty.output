Feature: AI Assistant Integration
  As a developer using VDE
  I want to use the AI assistant to manage my environment
  So I can control everything using natural language
  Scenario: Basic AI assistance 
    Given I want help with VDE
    When I say "help me with VDE"
    Then the AI should explain available commands
    And I should understand what I can do

  Scenario: AI understands complex requests 
    Given I need a complete development stack
    When I tell the AI "I need a Python backend with PostgreSQL database and Redis cache"
    Then the AI should understand all components
    And create Python, PostgreSQL, and Redis VMs
    And configure them to work together

  Scenario: AI provides context-aware help 
    Given I have certain VMs running
    When I ask "what do I have running?"
    Then the AI should show my current state
    And suggest relevant next actions
    And provide helpful information

  Scenario: AI handles ambiguous requests 
    Given my request is not clear
    When I say "start my environment"
    Then the AI should ask for clarification
    And the AI should make a reasonable guess based on context
    And the AI should explain what it's doing

  Scenario: AI remembers context 
    Given I just created a Python VM
    When I say "start it"
    Then the AI should know "it" means Python
    And start the Python VM

  Scenario: AI suggests optimizations 
    Given I'm doing something inefficient
    When I ask for advice
    Then the AI should suggest better approaches
    And explain why they're better
    And offer to implement them

  Scenario: AI handles errors gracefully 
    Given something goes wrong
    When I ask the AI to fix it
    Then the AI should diagnose the problem
    And suggest solutions
    And offer to implement the fix

  Scenario: AI provides progress feedback 
    Given I start a long operation
    When the AI is executing it
    Then I should see progress updates
    And know what's happening
    And understand how long it will take

  Scenario: AI learns preferences 
    Given I use VDE regularly
    When I perform common actions
    Then the AI should learn my patterns
    And suggest shortcuts
    And anticipate my needs

  Scenario: AI explains technical details 
    Given I don't understand something
    When I ask "how does this work?"
    Then the AI should explain clearly
    And provide examples
    And offer more details if needed

  Scenario: AI handles multiple operations 
    Given I need to do several things
    When I say "create Python, start postgres, and show me how to connect"
    Then the AI should execute all operations
    And report on each one
    And confirm everything is complete

  Scenario: AI provides safety warnings 
    Given I'm about to do something risky
    When the AI detects the risk
    Then it should warn me
    And explain the danger
    And ask for confirmation

  Scenario: AI offers alternatives 
    Given I request something that might not be optimal
    When the AI has a better suggestion
    Then it should propose the alternative
    And explain the benefits
    And let me choose

  Scenario: AI works with dry-run mode 
    Given I want to see what will happen
    When I enable dry-run mode
    Then the AI should explain what it would do
    And not actually do it
    And let me confirm before executing

Feature: AI Assistant for Natural Language Control
  As a developer
  I want to control VDE using natural language
  So that I don't need to remember exact command syntax
  Scenario: Start VMs with conversational command 
    Given I have VMs created but not running
    When I say "start the python and rust vms"
    Then both python and rust VMs should start
    And I should not need to remember the exact command

  Scenario: Ask what VMs are available 
    Given I'm new to VDE
    When I ask "what vms can I create?"
    Then I should see a list of all available VM types
    And aliases should be shown
    And I should understand my options

  Scenario: Ask what's currently running 
    Given I have several VMs configured
    When I ask "what's currently running?"
    Then I should see which VMs are running
    And I should see which VMs are stopped
    And I should see SSH connection info for running VMs

  Scenario: Get help with available commands 
    Given I'm not sure what I can do
    When I ask "help" or "what can I do?"
    Then I should see available commands
    And example commands should be shown
    And I should understand how to use VDE

  Scenario: Create VM with natural language 
    Given I want a go development environment
    When I say "create a go vm"
    Then go VM should be created
    And I should not need to remember create-virtual-for syntax

  Scenario: Stop all VMs at once 
    Given I have multiple VMs running
    When I say "stop everything" or "shutdown all"
    Then all VMs should be stopped
    And I should not need to list each VM

  Scenario: Rebuild VM with natural language 
    Given I've modified a Dockerfile
    When I say "rebuild and start python"
    Then python VM should be rebuilt and started
    And I should not need to remember --rebuild flag

  Scenario: Ask how to connect to a VM 
    Given I want to SSH into my VM
    When I ask "how do I connect to python?"
    Then I should see the SSH command
    And I should see the port number
    And I should see VSCode Remote-SSH instructions

  Scenario: List only language VMs 
    Given I want to see available programming languages
    When I say "show all language vms"
    Then I should see python, rust, go, js, etc.
    But I should not see postgres, redis, nginx

  Scenario: List only service VMs 
    Given I want to see available services
    When I say "what services are available?"
    Then I should see postgres, redis, mongodb, nginx
    But I should not see language VMs

  Scenario: Handle ambiguous input gracefully 
    Given I'm not sure of the exact command
    When I say something vague like "do something with containers"
    Then I should get helpful guidance
    And available options should be suggested
    And I should not get a cryptic error

  Scenario: Parse commands with typos 
    Given I make a typo in my command
    When I say "strt the python vm"
    Then the system should still understand my intent
    And the system should provide helpful correction suggestions

  Scenario: Complex multi-step requests 
    Given I want to do multiple things
    When I say "create a rust vm and start it with redis"
    Then rust VM should be created
    And rust and redis VMs should be started
    And I should not need separate commands

  Scenario: Status of specific VMs 
    Given I have multiple VMs
    When I ask "show status of python and rust"
    Then I should see status for only those VMs
    And other VMs should not clutter the output

  Scenario: Use common aliases naturally 
    Given I'm used to saying "js" instead of "javascript"
    When I say "start js vm"
    Then javascript VM should start
    And common aliases should work naturally

Feature: Cache System
  As a developer
  I want VM type data to be cached for performance
  So that scripts don't reparse configuration on every invocation
  Scenario: Cache VM types after first load 
    Given vm-types.conf has been modified
    When VM types are loaded for the first time
    Then cache file should be created at ".cache/vm-types.cache"
    And cache file should contain all VM type data

  Scenario: Load from cache when config unchanged 
    Given VM types cache exists
    And vm-types.conf has not been modified since cache
    When VM types are loaded
    Then data should be loaded from cache
    And vm-types.conf should not be reparsed

  Scenario: Invalidate cache when config is modified 
    Given VM types cache exists
    And vm-types.conf has been modified after cache
    When VM types are loaded
    Then cache should be invalidated
    And vm-types.conf should be reparsed
    And cache file should be updated

  Scenario: Force cache bypass with --no-cache flag 
    Given VM types cache exists and is valid
    When VM types are loaded with --no-cache
    Then cache should be bypassed
    And vm-types.conf should be reparsed

  Scenario: Cache stores all VM type arrays 
    Given VM types are cached
    When cache is read
    Then VM_TYPE array should be populated
    And VM_ALIASES array should be populated
    And VM_DISPLAY array should be populated
    And VM_INSTALL array should be populated
    And VM_SVC_PORT array should be populated

  Scenario: Cache file format is parseable 
    Given VM types cache exists
    When cache file is read
    Then each line should match "ARRAY_NAME:key=value" format
    And comments should start with "#"

  Scenario: Port registry cache persists allocations 
    Given ports have been allocated for VMs
    When port registry is saved
    Then cache file should exist at ".cache/port-registry"
    And each VM should be mapped to its port

  Scenario: Load port registry from cache 
    Given port registry cache exists
    When port registry is loaded
    Then allocated ports should be available without scanning compose files

  Scenario: Verify port registry consistency 
    Given port registry cache exists
    And a VM has been removed
    When port registry is verified
    Then removed VM should be removed from registry
    And cache file should be updated

  Scenario: Rebuild port registry from compose files 
    Given port registry cache is missing or invalid
    When port registry is verified
    Then registry should be rebuilt by scanning docker-compose files
    And all allocated ports should be discovered

  Scenario: Cache directory is created if missing 
    Given .cache directory does not exist
    When cache operation is performed
    Then .cache directory should be created

  Scenario: Cache mtime comparison works correctly 
    Given cache file was created before config file
    And cache file is newer than config file
    When cache validity is checked
    Then cache should be considered valid

  Scenario: Invalidate cache programmatically 
    Given VM types cache exists
    When invalidate_vm_types_cache is called
    Then cache file should be removed
    And _VM_TYPES_LOADED flag should be reset

  Scenario: Lazy load VM types only when needed 
    Given library has been sourced
    And no VM operations have been performed
    When VM types are first accessed
    Then VM types should be loaded at that time
    And not during initial library sourcing

Feature: Team Collaboration and Project Sharing
  As a developer working with a team
  I want to share VDE configurations with my team
  So that everyone has consistent development environments
  Scenario: New team member sets up VDE for first time 
    Given I am a new developer joining the team
    And I have cloned the project repository
    And the project contains VDE configuration in configs/
    When I run the initial setup
    Then VDE should detect my operating system
    And appropriate base images should be built
    And my SSH keys should be automatically configured
    And I should see available VMs with "list-vms"

  Scenario: Share project VM configuration via git 
    Given my project has a "python" VM configuration
    And the docker-compose.yml is committed to the repo
    When a teammate clones the repository
    And they run "create-virtual-for python"
    Then they should get the same Python environment I have
    And all dependencies should be installed
    And project directories should be properly mounted

  Scenario: Sync team member's SSH config changes 
    Given the team has updated SSH config templates
    And I pull the latest changes
    When I create or restart any VM
    Then my SSH config should be updated with new entries
    And my existing SSH entries should be preserved
    And I should not lose my personal SSH configurations

  Scenario: Collaborate with shared PostgreSQL service 
    Given the team uses PostgreSQL for development
    And postgres VM configurationpostgreshe repository
    When each team member starts "postgres" VM
    Then each developer gets their own isolated PostgreSQL instance
    And data persists in each developer's local data/postgres/
    And developers don't interfere with each other's databases

  Scenario: Development environment matches production 
    Given our production uses PostgreSQL 14, Redis 7, and Node 18
    When I configure VDE with matching versions
    Then my local development should match production
    And version-specific bugs can be caught early
    And deployment surprises are minimized

  Scenario: Onboard new developer with pre-built VMs 
    Given the team maintains a set of pre-configured VMs
    And documentation explains how to create each VM
    When a new developer joins
    And they follow the setup instructions
    Then they should have all VMs running in minutes
    And they can start contributing immediately

  Scenario: Team agrees on standard VM types 
    Given the team defines standard VM types in vm-types.conf
    When new projects need specific language support
    And the VM type is already defined
    Then anyone can create the VM using the standard name
    And everyone gets consistent configurations
    And aliases work predictably across the team

  Scenario: Document project-specific VM requirements 
    Given a project requires specific services (postgres, redis, nginx)
    When the project README documents required VMs
    And developers run the documented create commands
    Then all developers have compatible environments
    And "docker-compose up" works for everyone
    And local development matches the documented setup

  Scenario: Share environment variables via env-files 
    Given a project needs environment variables for configuration
    And env-files/project-name.env is committed to git (with defaults)
    When a developer creates and starts the VM
    Then environment variables should be loaded from env-file
    And developers can override variables in local env-file (gitignored)
    And sensitive variables stay out of version control

  Scenario: Collaborative debugging with matching environments 
    Given a developer cannot reproduce a bug
    When another developer shares their exact VM configuration
    And the first developer recreates the VM
    Then both developers have identical environments
    And the bug becomes reproducible
    And debugging becomes more effective

  Scenario: Team expands VDE with new language support 
    Given the team decides to add "dart" support
    When one developer runs "add-vm-type dart 'apt-get install -y dart'"
    And commits the vm-types.conf change
    Then all developers can create dart VMs
    And everyone has access to the same dart environment
    And the team's language support grows consistently

Feature: Configuration Management
  As a developer
  I want to configure VDE to match my project needs
  So that my development environment matches my requirements
  Scenario: Configure VM with custom install command 
    Given I need specific packages in my Python VM
    When I add a VM type with custom install command
    Then "apt-get install -y python3 python3-pip my-package" should run
    And my custom packages should be available in the VM

  Scenario: Add service VM with custom port 
    Given I need a MySQL service on port 3306
    When I run "add-vm-type --type service --svc-port 3306 mysql 'apt-get install -y mysql-server'"
    Then mysql VM should be created
    And port 3306 should be mapped to host
    And I can connect to MySQL from other VMs

  Scenario: Configure VM with multiple service ports 
    Given I need a service that exposes multiple ports
    When the VM type configuration includes multiple ports
    Then all ports should be mapped in docker-compose.yml
    And each port should be accessible from host
    And each port should be accessible from other VMs

  Scenario: Set display name for VM 
    Given I want friendly names in listings
    When I add VM type with --display "Go Language"
    Then "Go Language" should appear in list-vms output
    And the display name should be used in all user-facing messages

  Scenario: Configure aliases for VM 
    Given I want to reference VMs with short names
    When I add VM type with aliases "js,node,nodejs"
    Then I can use any alias to reference the VM
    And "start-virtual js", "start-virtual node", "start-virtual nodejs" all work
    And aliases should show in list-vms output

  Scenario: Override default port ranges 
    Given I need different port ranges for my environment
    When I modify VDE_LANG_PORT_START and VDE_LANG_PORT_END
    Then new VMs should use ports in my custom range
    And existing VMs keep their allocated ports

  Scenario: Configure custom Docker base image 
    Given I need a different base OS or variant
    When I modify base-dev.Dockerfile
    And I rebuild VMs with --rebuild
    Then VMs should use my custom base image
    And my OS-specific requirements should be met

  Scenario: Configure environment variables for VM 
    Given my application needs specific environment variables
    When I create env-files/myapp.env
    And I add variables like NODE_ENV=development
    Then variables should be available in the VM
    And variables are loaded automatically when VM starts

  Scenario: Configure custom UID/GID for container user 
    Given my host user has different UID/GID than 1000
    When I modify the UID and GID in docker-compose.yml
    Then container user should match my host user
    And file permissions should work correctly
    And I won't have permission issues on shared volumes

  Scenario: Configure volume mounts for VM 
    Given I need to mount specific directories into the VM
    When I modify the volumes section in docker-compose.yml
    Then my custom directories should be mounted
    And files should be shared between host and VM
    And changes should sync immediately

  Scenario: Configure container resource limits 
    Given I want to limit VM memory usage
    When I add mem_limit to docker-compose.yml
    Then container should be limited to specified memory
    And container should not exceed the limit
    And my system stays responsive

  Scenario: Configure DNS resolution for VMs 
    Given I need custom DNS for my VMs
    When I modify DNS settings in docker-compose.yml
    Then VMs should use my DNS servers
    And name resolution should work as configured

  Scenario: Configure network for VM isolation 
    Given I need some VMs on isolated networks
    When I create custom networks in docker-compose.yml
    Then VMs can be isolated as needed
    And specific VMs can communicate
    And other VMs cannot reach isolated VMs

  Scenario: Configure log output for VM 
    Given I want to control VM logging
    When I modify logging configuration in docker-compose.yml
    Then logs can go to files, syslog, or stdout
    And log rotation can be configured
    And I can control log verbosity

  Scenario: Configure restart policy 
    Given I want VMs to restart automatically
    When I set restart: always in docker-compose.yml
    Then VM restarts if it crashes
    And VM starts on system boot (if Docker does)
    And my environment recovers automatically

  Scenario: Configure health check for VM 
    Given I want to know if VM is healthy
    When I add healthcheck to docker-compose.yml
    Then Docker monitors VM health
    And I can see health status in docker ps
    And unhealthy VMs can be restarted automatically

  Scenario: Share configuration across team 
    Given I want team to use same VM configuration
    When I commit docker-compose.yml and env-files to git
    Then team members get identical configuration
    And environment is consistent across team
    And "works on my machine" is reduced

  Scenario: Local-only configuration overrides 
    Given I need local configuration different from team
    When I create .env.local or docker-compose.override.yml
    And I add it to .gitignore
    Then my local overrides are not committed
    And team configuration is not affected
    And I can customize for my environment

  Scenario: Configure multiple instances of same VM type 
    Given I need two different Python environments
    When I create "python-dev" and "python-test" VMs
    Then both should use python base configuration
    But each should have separate data directory
    And each can run independently

  Scenario: Validate configuration before use 
    Given I've modified VM configuration
    When I run validation or try to start VM
    Then syntax errors should be caught
    And invalid ports should be rejected
    And missing required fields should be reported

  Scenario: Migrate configuration after VDE update 
    Given VDE configuration format has changed
    When I pull the latest VDE
    Then old configurations should still work
    And migration should happen automatically
    And I should be told about manual steps if needed

  Scenario: Reset configuration to defaults 
    Given I've made configuration changes I want to undo
    When I remove my custom configurations
    And I reload VM types
    Then default configurations should be used
    And my VMs work with standard settings

  Scenario: Debug configuration issues 
    Given my VM won't start due to configuration
    When I check docker-compose config
    Then I should see the effective configuration
    And errors should be clearly indicated
    And I can identify the problematic setting

Feature: Daily Development Workflow
  As a developer using VDE
  I want to manage my development containers efficiently
  So I can focus on coding without managing infrastructure
  Scenario: Starting my development environment 
    Given I have VDE installed
    When I request to start my Python development environment
    Then the Python VM should be started
    And SSH access should be available on the configured port
    And my workspace directory should be mounted

  Scenario: Checking what's currently running 
    Given I have several VMs running
    When I ask "what's running?"
    Then I should see a list of all running VMs
    And each VM should show its status
    And the list should include both language and service VMs

  Scenario: Getting connection information for a VM 
    Given I have a Python VM running
    When I ask "how do I connect to Python?"
    Then I should receive SSH connection details
    And the details should include the hostname
    And the details should include the port number
    And the details should include the username

  Scenario: Stopping work for the day 
    Given I have multiple VMs running
    When I request to "stop everything"
    Then all running VMs should be stopped
    And no containers should be left running
    And the operation should complete without errors

  Scenario: Restarting a VM with rebuild 
    Given I have a Python VM running
    When I request to "restart python with rebuild"
    Then the Python VM should be stopped
    And the container should be rebuilt from the Dockerfile
    And the Python VM should be started again
    And my workspace should still be mounted

  Scenario: Starting multiple VMs at once 
    Given I need a full stack environment
    When I request to "start python and postgres"
    Then both Python and PostgreSQL VMs should start
    And they should be on the same Docker network
    And they should be able to communicate

  Scenario: Creating a new VM for the first time 
    Given I want to try a new language
    When I request to "create a Go VM"
    Then the Go VM configuration should be created
    And the Docker image should be built
    And SSH keys should be configured
    And the VM should be ready to start

Feature: Daily Development Workflow
  As a developer
  I want to manage multiple development environments seamlessly
  So that I can switch between projects and languages efficiently
  Feature: Daily Development Workflow 

  Scenario: Start my daily development VMs 
    Given VDE is installed on my system
    And Docker is running
    And I have start-virtual python rust postgres
    Given I previously created VMs for "python", "rust", and "postgres"
    When I run "start-virtual python rust postgres"
    Then all three VMs should be running
    And I should be able to SSH to "python-dev" on allocated port
    And I should be able to SSH to "rust-dev" on allocated port
    And PostgreSQL should be accessible from language VMs

  Scenario: Create a new language VM for a project 
    Given VDE is installed on my system
    And Docker is runningo
    And I have create-virtual-for go
    Given I need to start a "golang" project
    But I don't have a "go" VM yet
    When I run "create-virtual-for go"
    Then a go development environment should be created
    And docker-compose.yml should be configured for go
    And SSH config entry for "go-dev" should be added
    And projects/go directory should be created
    And I can start the VM with "start-virtual go"

  Scenario: Switch from Python to Rust project 
    Given VDE is installed on my system
    And Docker is running
    And I have SSH keys configured
    Given I have start-virtual rustg
    And I have "rust" VM created but not running
    When I want to work on a Rust project instead
    And I run "start-virtual rust"
    Then both "python" and "rust" VMs should be running
    And I can SSH to both VMs from my terminal
    And each VM has isolated project directories

  Scenario: Connect to PostgreSQL from Python VM 
    Given VDE is installed on my system
    And Docker is running
    And I have SSH keys configured
    Given "postgrpsql -h postgres -U devuser
    And "python" VM is running
    When I SSH into "python-dev"
    And I run "psql -h postgres -U devuser"
    Then I should be connected to PostgreSQL
    And I can query the database
    And the connection uses the container network

  Scenario: Shut down all VMs at end of day 
    Given VDE is installed on my system
    And Docker is running
    And I have SSH keys configured
    Given multiple VMs are running
    When I run "shutdown-virtual all"
    Then all VMs should be stopped
    But VM configurations should remain for next session
    And docker ps should show no VDE containers running

  Scenario: Run multiple language VMs for a polyglot project 
    Given VDE is installed on my system
    And Docker is running
    And I have start-virtual python js redis
    Given I have a project using Python, JavaScript, and Redis
    When I run "start-virtual python js redis"
    Then all three VMs should be running
    And Python VM can make HTTP requests to JavaScript VM
    And Python VM can connect to Redis
    And each VM can access shared project directories

  Scenario: Rebuild a VM after modifying its Dockerfile 
    Given VDE is installed on my system
    And Docker is running
    And I have SSH keys configured
    Given I have start-virtual python --rebuild to add a new package
    And "python" VM is currently running
    When I run "start-virtual python --rebuild"
    Then the VM should be rebuilt with the new Dockerfile
    And the VM should be running after rebuild
    And the new package should be available in the VM

  Scenario: Remove VM I no longer need 
    Given VDE is installed on my system
    And Docker is running
    And I have SSH keys configured
    Given I have an old "ruby" VM I don't use anymore
    When I run the removal process for "ruby"
    Then the docker-compose.yml should be deleted
    And SSH config entry should be removed
    But the projects/ruby directory should be preserved
    And I can recreate it later if needed

  Scenario: Add support for a new language 
    Given VDE is installed on my system
    And Docker is running
    And I have add-vm-type --type lang --display 'Zig' zig 'apt-get install -y zig'
    Given VDE doesn't support "zig" yet
    When I run "add-vm-type --type lang --display 'Zig' zig 'apt-get install -y zig'"
    Then "zig" should be available as a VM type
    And I can create a zig VM with "create-virtual-for zig"
    And zig should appear in "list-vms" output

  Scenario: Check what VMs I can create 
    Given VDE is installed on my system
    And Docker is running
    And I have SSH keys configured
    Given I want to see what development environments are available
    When I run "list-vms"
    Then all language VMs should be listed with aliases
    And all service VMs should be listed with ports
    And I can see which VMs are created vs just available

  Scenario: Quickly check what's running 
    Given VDE is installed on my system
    And Docker is running
    And I have list-vms --createdd
    Given I have several VMs configured
    When I run "list-vms --created"
    Then I should see only VMs that have been created
    And their status (running/stopped) should be shown
    And I can identify which VMs to start or stop

  Scenario: Create test environment with database 
    Given VDE is installed on my system
    And Docker is running
    And I have SSH keys configured
    Given I need to test my application with a real database
    When I create "postgres" and "redis" service VMs
    And I create my language VM (e.g., "python")
    And I start all three VMs
    Then my application can connect to test database
    And test data is isolated from development data
    And I can stop test VMs independently

  Scenario: VDE handles port conflicts gracefully 
    Given VDE is installed on my system
    And Docker is running
    And I have SSH keys configured
    Given a system service is using port 2200
    When I create a new language VM
    Then VDE should allocate the next available port (2201)
    And the VM should work correctly on the new port
    And SSH config should reflect the correct port

Feature: Debugging and Troubleshooting
  As a developer
  I want tools to diagnose and fix VM issues
  So that I can quickly resolve problems and continue working
  Scenario: Diagnose why VM won't start 
    Given I tried to start a VM but it failed
    When I check the VM status
    Then I should see a clear error message
    And I should know if it's a port conflict, Docker issue, or configuration problem

  Scenario: View VM logs for debugging 
    Given a VM is running but misbehaving
    When I run "docker logs <vm-name>"
    Then I should see the container logs
    And I can identify the source of the problem

  Scenario: Access VM shell for debugging 
    Given a VM is running
    When I run "docker exec -it <vm-name> /bin/zsh"
    Then I should have shell access inside the container
    And I can investigate issues directly

  Scenario: Rebuild VM from scratch after corruption 
    Given a VM seems corrupted or misconfigured
    When I stop the VM
    And I remove the VM directory
    And I recreate the VM
    Then I should get a fresh VM
    And old configuration issues should be resolved

  Scenario: Check if port is already in use 
    Given I get a "port already allocated" error
    When I check what's using the port
    Then I should see which process is using it
    And I can decide to stop the conflicting process
    And VDE can allocate a different port

  Scenario: Verify SSH connection is working 
    Given I cannot SSH into a VM
    When I check the SSH config
    And I verify the VM is running
    And I verify the port is correct
    Then I can identify if the issue is SSH, Docker, or the VM itself

  Scenario: Test database connectivity from VM 
    Given my application can't connect to the database
    When I SSH into the application VM
    And I try to connect to the database VM directly
    Then I can see if the issue is network, credentials, or database state

  Scenario: Inspect docker-compose configuration 
    Given I need to verify VM configuration
    When I look at the docker-compose.yml
    Then I should see all volume mounts
    And I should see all port mappings
    And I should see environment variables
    And I can verify the configuration is correct

  Scenario: Verify volumes are mounted correctly 
    Given my code changes aren't reflected in the VM
    When I check the mounts in the container
    Then I can see if the volume is properly mounted
    And I can verify the host path is correct

  Scenario: Clear Docker cache to fix build issues 
    Given a VM build keeps failing
    When I rebuild with --no-cache
    Then Docker should pull fresh images
    And build should not use cached layers

  Scenario: Reset a VM to initial state 
    Given I've made changes I want to discard
    When I stop the VM
    And I remove the container but keep the config
    And I start it again
    Then I should get a fresh container
    And my code volumes should be preserved

  Scenario: Verify network connectivity between VMs 
    Given two VMs can't communicate
    When I check the docker network
    Then I should see both VMs on "vde-network"
    And I can ping one VM from another

  Scenario: Check VM resource usage 
    Given a VM seems slow
    When I run "docker stats <vm-name>"
    Then I can see CPU and memory usage
    And I can identify resource bottlenecks

  Scenario: Validate VM configuration before starting 
    Given I think my docker-compose.yml might have errors
    When I run "docker-compose config"
    Then I should see any syntax errors
    And the configuration should be validated

  Scenario: Recover from Docker daemon issues 
    Given VMs won't start due to Docker problems
    When I check Docker is running
    And I restart Docker if needed
    Then VMs should start normally after Docker is healthy

  Scenario: Fix permission issues on shared volumes 
    Given I get permission denied errors in VM
    When I check the UID/GID configuration
    Then I should see if devuser (1000:1000) matches my host user
    And I can adjust if needed

  Scenario: Diagnose why tests fail in VM but pass locally 
    Given tests work on host but fail in VM
    When I compare the environments
    Then I can check for missing dependencies
    And I can verify environment variables match
    And I can check network access from the VM

Feature: Docker and Container Management
  As a developer using VDE
  I want VDE to handle Docker container complexity
  So I can focus on development without managing containers
  Scenario: Automatic Docker network creation 
    Given I start my first VM
    Then VDE should create the dev-net network
    And all VMs should join this network
    And VMs should be able to communicate by name

  Scenario: Port allocation for SSH 
    Given I create multiple VMs
    When each VM starts
    Then each should get a unique SSH port
    And ports should be auto-allocated from available range
    And no two VMs should have the same SSH port

  Scenario: Service port configuration 
    Given I create a PostgreSQL VM
    When it starts
    Then the PostgreSQL port should be mapped
    And I can connect to PostgreSQL from the host
    And other VMs can connect using the service name

  Scenario: Volume mounts for workspace 
    Given I start any VM
    Then my workspace directory should be mounted
    And files I create are visible on the host
    And changes persist across container restarts

  Scenario: Data persistence for services 
    Given I create a PostgreSQL VM
    When I stop and restart PostgreSQL
    Then my data should be preserved
    And databases should remain intact
    And I should not lose any data

  Scenario: Container resource limits 
    Given I have multiple running VMs
    When I check resource usage
    Then each container should have reasonable limits
    And no single VM should monopolize resources
    And the system should remain responsive

  Scenario: Container health monitoring 
    Given I have running VMs
    When I query VM status
    Then I should see which containers are healthy
    And I should see any that are failing
    And I should be able to identify issues

  Scenario: Cleaning up stopped containers 
    Given I have stopped several VMs
    When I start them again
    Then old containers should be removed
    And new containers should be created
    And no stopped containers should accumulate

  Scenario: Docker Compose integration 
    Given VDE creates a VM
    Then a docker-compose.yml file should be generated
    And I can manually use docker-compose if needed
    And the file should follow best practices

  Scenario: Multi-stage build optimization 
    Given I rebuild a language VM
    Then the build should use multi-stage Dockerfile
    And final images should be smaller
    And build cache should be used when possible

  Scenario: Container startup order 
    Given I have dependent services
    When I start them together
    Then they should start in a reasonable order
    And dependencies should be available when needed
    And the startup should complete successfully

  Scenario: Container isolation 
    Given I have multiple VMs running
    When one VM crashes
    Then other VMs should continue running
    And the crash should not affect other containers
    And I can restart the crashed VM independently

  Scenario: Container logs 
    Given I have a running VM
    When I need to debug an issue
    Then I can view the container logs
    And logs should show container activity
    And I can troubleshoot problems

Feature: Docker Operations
  As a developer
  I want reliable Docker Compose operations with error handling
  So that VM containers start and stop correctly
  Scenario: Build Docker image for VM 
    Given VM "python" docker-compose.yml exists
    When I start VM "python"
    Then docker-compose build should be executed
    And image should be built successfully

  Scenario: Start container with docker-compose up 
    Given VM "python" image exists
    When I start VM "python"
    Then docker-compose up -d should be executed
    And container should be running

  Scenario: Stop container with docker-compose down 
    Given VM "python" is running
    When I stop VM "python"
    Then docker-compose down should be executed
    And container should not be running

  Scenario: Restart container 
    Given VM "python" is running
    When I restart VM "python"
    Then container should be stopped
    And container should be started
    And container should have new container ID

  Scenario: Rebuild with --build flag 
    Given VM "python" is running
    When I start VM "python" with --rebuild
    Then docker-compose up --build should be executed
    And image should be rebuilt

  Scenario: Rebuild without cache with --no-cache flag 
    Given VM "python" is running
    When I start VM "python" with --rebuild and --no-cache
    Then docker-compose up --build --no-cache should be executed

  Scenario: Handle port allocation errors 
    Given all ports in range are in use
    When I create a new VMNo available ports
    Then error should indicate "No available ports"
    And VM should not be created

  Scenario: Handle Docker daemon not running 
    Given Docker daemon is not running
    When I try to start a VMCannot connect to Docker daemon
    Then error should indicate "Cannot connect to Docker daemon"
    And command should fail gracefully

  Scenario: Handle network errors 
    Given vde-network does not exist
    When I start a VM
    Then network should be created automatically
    And error should indicate network issue

  Scenario: Handle image pull failures 
    Given image does not exist locally
    And registry is not accessible
    When I start a VM
    Then error should indicate image pull failure
    And container should not start

  Scenario: Parse Docker error messages 
    Given docker-compose operation fails
    When stderr is parsed
    Then "port is already allocated" should map to port conflict error
    And "network.*not found" should map to network error
    And "permission denied" should map to permission error

  Scenario: Retry transient failures with exponential backoff 
    Given docker-compose operation fails with transient error
    When operation is retried
    Then retry should use exponential backoff
    And maximum retries should not exceed 3
    And delay should be capped at 30 seconds

  Scenario: Handle disk space errors 
    Given no disk space is availano space left on device
    When I try to start a VM
    Then error should indicate "no space left on device"
    And command should fail immediately

  Scenario: Get container status 
    Given VM "python" exists
    When I check VM status
    Then status should be one of: "running", "stopped", "not_created", "unknown"

  Scenario: Detect running containers 
    Given multiple VMs are running
    When I get running VMs
    Then all running containers should be listed
    And stopped containers should not be listed

  Scenario: Use correct docker-compose project name 
    Given VM "python" is started
    Then docker-compose project should be "vde-python"

  Scenario: Container naming follows convention 
    Given language VM "python" is started
    Then container should be named "python-dev"
    Given service VM "postgres" is started
    Then container should be named "postgres"

  Scenario: Volume mounts are created correctly 
    Given VM "python" is started
    Then projects/python volume should be mounted
    And logs/python volume should be mounted
    And volume should be mounted from host directory

  Scenario: Environment variables are passed to container 
    Given VM "python" has env file
    When container is started
    Then env file should be read by docker-compose
    And SSH_PORT variable should be available in container

Feature: Daily Development Workflow
  As documented in the VDE development workflows
  I want to follow the same patterns that are documented
  So that the tests match the documentation exactly
  Scenario: Example 1 - Python API with PostgreSQL Setup 
    Given I am following the documented Python API workflow
    When I plan to create a Python VM
    Then the plan should include the create_vm intent
    And the plan should include the Python VM

  Scenario: Example 1 - Create PostgreSQL for Python API 
    Given I have planned to create Python
    When I plan to create PostgreSQL
    Then the plan should include the create_vm intent
    And the plan should include the PostgreSQL VM

  Scenario: Example 1 - Start Both Python and PostgreSQL 
    Given I have created Python and PostgreSQL VMs
    When I plan to start both VMs
    Then the plan should include the start_vm intent
    And the plan should include both Python and PostgreSQL VMs

  Scenario: Example 1 - Get Connection Info for Python 
    Given I need to connect to the Python VM
    When I ask for connection information
    Then the plan should include the connect intent
    And the plan should include the Python VM

  Scenario: Example 1 - Verify PostgreSQL Accessibility 
    Given I have started the PostgreSQL VM
    When I check if postgres exists
    Then the VM should be recognized as a valid VM type
    And it should be marked as a service VM

  Scenario: Example 2 - Full-Stack JavaScript with Redis 
    Given I am following the documented JavaScript workflow
    When I plan to create JavaScript and Redis VMs
    Then the plan should include both VMs
    And the JavaScript VM should use the js canonical name

  Scenario: Example 2 - Resolve Node.js Alias 
    Given I want to use the Node.js name
    When I resolve the nodejs alias
    Then it should resolve to js
    And I can use either name in commands

  Scenario: Example 3 - Microservices Architecture Setup 
    Given I am creating a microservices architecture
    When I plan to create Python, Go, Rust, PostgreSQL, and Redis
    Then the plan should include all five VMs
    And each VM should be included in the VM list

  Scenario: Example 3 - Start All Microservice VMs 
    Given I have created the microservice VMs
    When I plan to start them all
    Then the plan should include the start_vm intent
    And all microservice VMs should be included

  Scenario: Example 3 - Verify All Microservice VMs Exist 
    Given I have created microservices
    When I check for each service VM
    Then Python should exist as a language VM
    And Go should exist as a language VM
    And Rust should exist as a language VM
    And PostgreSQL should exist as a service VM
    And Redis should exist as a service VM

  Scenario: Daily Workflow - Morning Setup 
    Given I am starting my development day
    When I plan to start Python, PostgreSQL, and Redis
    Then the plan should include all three VMs
    And the plan should use the start_vm intent

  Scenario: Daily Workflow - Check Status During Development 
    Given I am actively developing
    When I ask what's running
    Then the plan should include the status intent
    And I should be able to see running VMs

  Scenario: Daily Workflow - Connect to Primary VM 
    Given I need to work in my primary development environment
    When I ask how to connect to Python
    Then the plan should provide connection details
    And the plan should include the Python VM

  Scenario: Daily Workflow - Evening Cleanup 
    Given I am done with development for the day
    When I plan to stop everything
    Then the plan should include the stop_vm intent
    And the plan should apply to all running VMs

  Scenario: Troubleshooting - Step 1 Check Status 
    Given something isn't working correctly
    When I check the status
    Then I should receive status information
    And I should see which VMs are running

  Scenario: Troubleshooting - Step 3 Restart with Rebuild 
    Given I need to rebuild a VM to fix an issue
    When I plan to rebuild Python
    Then the plan should include the restart_vm intent
    And the plan should set rebuild=true flag

  Scenario: Troubleshooting - Step 4 Get Connection Info 
    Given I need to debug inside a container
    When I ask to connect to Python
    Then the plan should include the connect intent
    And I should receive SSH connection information

  Scenario: New Project Setup - Discover Available VMs 
    Given I am setting up a new project
    When I ask what VMs can I create
    Then the plan should include the list_vms intent
    And I should see all available VM types

  Scenario: New Project Setup - Choose Full Stack 
    Given I want a Python API with PostgreSQL
    When I plan to create Python and PostgreSQL
    Then both VMs should be included in the plan
    And the plan should use the create_vm intent

  Scenario: New Project Setup - Start Development Stack 
    Given I have created my VMs
    When I plan to start Python and PostgreSQL
    Then both VMs should start
    And they should be able to communicate

  Scenario: Adding Cache Layer - Create Redis 
    Given I have an existing Python and PostgreSQL stack
    When I plan to add Redis
    Then the plan should include the create_vm intent
    And the Redis VM should be included

  Scenario: Adding Cache Layer - Start Redis 
    Given I have created the Redis VM
    When I plan to start Redis
    Then the plan should include the start_vm intent
    And Redis should start without affecting other VMs

  Scenario: Switching Projects - Stop Current Project 
    Given I am working on one project
    When I plan to stop all VMs
    Then all running VMs should be stopped
    And I should be ready to start a new project

  Scenario: Switching Projects - Start New Project 
    Given I have stopped my current project
    When I plan to start Go and MongoDB
    Then the new project VMs should start
    And only the new project VMs should be running

  Scenario: Team Onboarding - Explore Languages 
    Given I am a new team member
    When I ask to list all languages
    Then I should see only language VMs
    And service VMs should not be included

  Scenario: Team Onboarding - Get Connection Help 
    Given I am new to the team
    When I ask how to connect to Python
    Then I should receive clear connection instructions
    And I should understand how to access the VM

  Scenario: Team Onboarding - Understand System 
    Given I am learning the VDE system
    When I ask for help
    Then I should see available commands
    And I should understand what I can do

  Scenario: Starting Already Running VM 
    Given I have a Python VM that is already running
    When I plan to start Python
    Then the plan should be generated
    And execution would detect the VM is already running
    And I would be notified that it's already running

  Scenario: Stopping Already Stopped VM 
    Given I have a stopped PostgreSQL VM
    When I plan to stop PostgreSQL
    Then the plan should be generated
    And execution would detect the VM is not running
    And I would be notified that it's already stopped

  Scenario: Creating Existing VM 
    Given I already have a Go VM configured
    When I plan to create Go again
    Then the plan should be generated
    And execution would detect the VM already exists
    And I would be notified of the existing VM

  Scenario: Documentation Accuracy - Verify Examples Work 
    Given the documentation shows specific VM examples
    When I verify the documented VMs
    Then Python should be a valid VM type
    And JavaScript should be a valid VM type
    And all microservice VMs should be valid

  Scenario: Performance - Quick Plan Generation 
    Given I need to plan my daily workflow
    When I generate plans for morning setup, checks, and cleanup
    Then all plans should be generated quickly
    And the total time should be under 500ms

Feature: Error Handling and Recovery
  As a developer using VDE
  I want the system to handle errors gracefully
  So I can recover quickly from problems
  Scenario: Invalid VM name handling 
    Given I try to use a VM that doesn't exist
    When I request to "start nonexistent-vm"
    Then I should receive a clear error message
    And the error should explain what went wrong
    And suggest valid VM names

  Scenario: Port conflict resolution 
    Given a port is already in use
    When I try to start a VM
    Then VDE should detect the conflict
    And allocate an available port
    And continue with the operation

  Scenario: Docker daemon not running 
    Given Docker is not available
    When I try to start a VM
    Then I should receive a helpful error
    And the error should explain Docker is required
    And suggest how to fix it

  Scenario: Insufficient disk space 
    Given my disk is nearly full
    When I try to create a VM
    Then VDE should detect the issue
    And warn me before starting
    And suggest cleaning up

  Scenario: Network creation failure 
    Given the Docker network can't be created
    When I start a VM
    Then VDE should report the specific error
    And suggest troubleshooting steps
    And offer to retry

  Scenario: Build failure recovery 
    Given a VM build fails
    When I examine the error
    Then I should see what went wrong
    And get suggestions for fixing it
    And be able to retry after fixing

  Scenario: Container startup timeout 
    Given a container takes too long to start
    When VDE detects the timeout
    Then it should report the issue
    And show the container logs
    And offer to check the status

  Scenario: SSH connection failure 
    Given a container is running but SSH fails
    When I try to connect
    Then VDE should diagnose the problem
    And check if SSH is running
    And verify the SSH port is correct

  Scenario: Permission denied errors 
    Given I don't have permission for an operation
    When VDE encounters the error
    Then it should explain the permission issue
    And suggest how to fix it
    And offer to retry with proper permissions

  Scenario: Configuration file errors 
    Given a docker-compose.yml is malformed
    When I try to use the VM
    Then VDE should detect the error
    And show the specific problem
    And suggest how to fix the configuration

  Scenario: Graceful degradation 
    Given one VM fails to start
    When I start multiple VMs
    Then other VMs should continue
    And I should be notified of the failure
    And successful VMs should be listed

  Scenario: Automatic retry logic 
    Given a transient error occurs
    When VDE detects it's retryable
    Then it should automatically retry
    And limit the number of retries
    And report if all retries fail

  Scenario: Partial state recovery 
    Given an operation is interrupted
    When I try again
    Then VDE should detect partial state
    And complete the operation
    And not duplicate work

  Scenario: Clear error messages 
    Given any error occurs
    When the error is displayed
    Then it should be in plain language
    And explain what went wrong
    And suggest next steps

  Scenario: Error logging 
    Given an error occurs
    When VDE handles it
    Then the error should be logged
    And the error should have sufficient detail for debugging
    And I can find it in the logs directory

  Scenario: Rollback on failure 
    Given an operation fails partway through
    When the failure is detected
    Then VDE should clean up partial state
    And return to a consistent state
    And allow me to retry cleanly

Feature: Installation and Initial Setup
  As a developer
  I want to install and configure VDE on my system
  So that I can start using development environments immediately
  Scenario: Fresh installation on new system 
    Given I have a new computer with Docker installed
    And I have cloned the VDE repository to ~/dev
    When I run the initial setup script
    Then VDE should be properly installed
    And required directories should be created
    And I should see success message

  Scenario: Prerequisites are checked 
    Given I want to install VDE
    When the setup script runs
    Then it should verify Docker is installed
    And it should verify docker-compose is available
    And it should verify zsh is available
    And it should report missing dependencies clearly

  Scenario: Create required directory structure 
    Given VDE is being installed
    When the setup completes
    Then configs/ directory should exist
    And templates/ directory should exist with templates
    And data/ directory should exist for persistent data
    And logs/ directory should exist
    And projects/ directory should exist for code
    And env-files/ directory should exist
    And backup/ directory should exist
    And cache/ directory should exist

  Scenario: Generate or detect SSH keys 
    Given I'm setting up VDE for the first time
    When SSH keys are checked
    Then if keys exist, they should be detected
    And if no keys exist, ed25519 keys should be generated
    And public keys should be copied to public-ssh-keys/
    And .keep file should exist in public-ssh-keys/

  Scenario: Initial SSH configuration 
    Given VDE is being set up
    When setup completes
    Then backup/ssh/config should exist as a template
    And the template should show proper SSH config format
    And I should be able to use it as reference

  Scenario: Load VM types configuration 
    Given VDE is installed
    When I run list-vms
    Then all predefined VM types should be shown
    And python, rust, js, csharp, ruby should be listed
    And postgres, redis, mongodb, nginx should be listed
    And aliases should be shown (py, js, etc.)

  Scenario: Set up shell environment 
    Given I want VDE commands available everywhere
    When I add VDE scripts to my PATH
    Then I can run vde commands from any directory
    And I can run start-virtual, shutdown-virtual, etc.
    And tab completion should work

  Scenario: Verify Docker permissions 
    Given VDE is being installed
    When setup checks Docker
    Then I should be warned if I can't run Docker without sudo
    And instructions should be provided for fixing permissions
    And setup should continue with a warning

  Scenario: Create Docker network 
    Given VDE is being installed
    When the first VM is created
    Then vde-network should be created automatically
    And all VMs should use this network
    And VMs can communicate with each other

  Scenario: First time creation experience 
    Given I've just installed VDE
    When I run "create-virtual-for python"
    Then I should see helpful progress messages
    And configs/docker/python/ should be created
    And docker-compose.yml should be generated
    And SSH config should be updated
    And I should be told what to do next

  Scenario: Verify installation with health check 
    Given I've installed VDE
    When I run "vde-health" or check status
    Then I should see if VDE is properly configured
    And any issues should be clearly listed
    And I should get fix suggestions for each issue

  Scenario: Upgrade existing installation 
    Given I have an older version of VDE
    When I pull the latest changes
    Then my existing VMs should continue working
    And new VM types should be available
    And my configurations should be preserved
    And I should be told about any manual migration needed

  Scenario: Uninstall or cleanup 
    Given I no longer want VDE on my system
    When I want to remove it
    Then I can stop all VMs
    And I can remove VDE directories
    And my SSH config should be cleaned up
    And my project data should be preserved if I want

  Scenario: Installation on different platforms 
    Given I'm installing VDE
    When the setup detects my OS (Linux/Mac)
    Then appropriate paths should be used
    And platform-specific adjustments should be made
    And the installation should succeed

  Scenario: Docker image availability 
    Given I'm setting up VDE for the first time
    When I create my first VM
    Then required Docker images should be pulled
    And base images should be built if needed
    And I should see download/build progress

  Scenario: Quick start after installation 
    Given VDE is freshly installed
    When I want to start quickly
    Then I can run "create-virtual-for python && start-virtual python"
    And I should have a working Python environment
    And I can start coding immediately

  Scenario: Documentation is available 
    Given VDE is installed
    When I need help
    Then README.md should provide overview
    And Technical-Deep-Dive.md should explain internals
    And tests/README.md should explain testing
    And help text should be available in commands

  Scenario: Validate installation 
    Given VDE has been installed
    When I run validation checks
    Then all scripts should be executable
    And all templates should be present
    And vm-types.conf should be valid
    And all directories should have correct permissions

Feature: Multi-Project Workflow
  As a developer working on multiple projects
  I want to switch between different development environments
  So I can work on different projects without configuration conflicts
  Scenario: Setting up a web development project 
    Given I am starting a new web project
    When I request to "create JavaScript and nginx"
    Then the JavaScript VM should be created
    And the nginx VM should be created
    And both should be configured for web development

  Scenario: Switching from web to backend project 
    Given I have web containers running (JavaScript, nginx)
    When I request to "stop all and start python and postgres"
    Then the web containers should be stopped
    And the Python VM should start
    And the PostgreSQL VM should start
    And only the backend stack should be running

  Scenario: Setting up a microservices architecture 
    Given I am building a microservices application
    When I request to "create Go, Rust, and nginx"
    Then the Go VM should be created for one service
    And the Rust VM should be created for another service
    And the nginx VM should be created as a gateway

  Scenario: Starting all microservices at once 
    Given I have created my microservice VMs
    When I request to "start all services"
    Then all service VMs should start
    And they should be able to communicate on the Docker network
    And each should have its own SSH port

  Scenario: Data science project setup 
    Given I am doing data analysis
    When I request to "start python and r"
    Then the Python VM should start
    And the R VM should start
    And both should have data science tools available

  Scenario: Full stack web application 
    Given I need a complete web stack
    When I request to "create Python, PostgreSQL, Redis, and nginx"
    Then the Python VM should be for the backend API
    And PostgreSQL should be for the database
    And Redis should be for caching
    And nginx should be for the web server
    And all should be on the same network

  Scenario: Mobile development with backend 
    Given I am developing a mobile app with backend
    When I request to "start flutter and postgres"
    Then the Flutter VM should start for mobile development
    And PostgreSQL should start for the backend database
    And both should be accessible via SSH

  Scenario: Cleaning up between projects 
    Given I have finished working on one project
    When I request to "stop everything"
    Then all containers should stop
    And I can start a fresh environment for another project
    And there should be no leftover processes

Feature: Natural Language Commands
  As a developer using VDE
  I want to control my environment using natural language
  So I don't have to remember specific command syntax
  Scenario: Simple intent commands 
    Given I want to perform common actions
    When I say "start python"
    Then the system should understand I want to start the Python VM
    And the appropriate action should be taken

  Scenario: Natural language variations 
    Given I can phrase commands in different ways
    When I say "launch the golang container"
    Then it should be equivalent to "start go"
    And the Go VM should start

  Scenario: Multiple VMs in one command 
    Given I need to work with multiple environments
    When I say "start python and postgres"
    Then both VMs should start
    And the command should work the same as "start python, postgres"

  Scenario: Using aliases instead of canonical names 
    Given I know a VM by its alias
    When I say "create nodejs environment"
    Then it should work the same as "create js"
    And the JavaScript VM should be created

  Scenario: Descriptive status queries 
    Given I want to know what's running
    When I ask "what's currently running?"
    Then I should see the status
    And it should work the same as "status"

  Scenario: Asking for help naturally 
    Given I'm not sure what to do
    When I ask "what can I do?"
    Then I should see help information
    And available commands should be explained

  Scenario: Connection help requests 
    Given I need to connect to a VM
    When I ask "how do I connect to the Python environment?"
    Then I should receive SSH connection instructions
    And the instructions should be clear and actionable

  Scenario: Rebuild requests 
    Given I need to rebuild a container
    When I say "rebuild python from scratch"
    Then the rebuild flag should be set
    And no cache should be used

  Scenario: Wildcard operations 
    Given I want to operate on all VMs of a type
    When I say "start all languages"
    Then all language VMs should start
    And service VMs should not be affected

  Scenario: Stopping everything 
    Given I'm done working
    When I say "stop everything"
    Then all running VMs should stop
    And it should be equivalent to "stop all"

  Scenario: Complex natural language queries 
    Given I use conversational language
    When I say "I need to set up a backend with Python and PostgreSQL"
    Then the system should understand I want to create VMs
    And Python and PostgreSQL should be created

  Scenario: Troubleshooting language 
    Given something isn't working
    When I say "restart the database"
    Then PostgreSQL should restart
    And the system should understand "database" means "postgres"

  Scenario: Case insensitive commands 
    Given I type commands in various cases
    When I say "START PYTHON"
    Then it should work the same as "start python"
    And case should not matter

  Scenario: Minimal typing commands 
    Given I want to type less
    When I say "start py and pg"
    Then it should understand "py" means "python"
    And "pg" should mean "postgres"

Feature: Natural Language Parser
  As a developer
  I want to control VDE using natural language commands
  So that I don't need to remember specific command syntax
  Scenario: Detect list VMs intent 
    When I parse "list all vms"
    Then intent should be "list_vms"

  Scenario: Detect list languages intent 
    When I parse "show all language vms"
    Then intent should be "list_vms"
    And filter should be "lang"

  Scenario: Detect list services intent 
    When I parse "what services are available"
    Then intent should be "list_vms"
    And filter should be "svc"

  Scenario: Detect create VM intent 
    When I parse "create a go vm"
    Then intent should be "create_vm"
    And VMs should include "go"

  Scenario: Detect create multiple VMs intent 
    When I parse "create python and rust"
    Then intent should be "create_vm"
    And VMs should include "python"
    And VMs should include "rust"

  Scenario: Detect start VM intent 
    When I parse "start the python vm"
    Then intent should be "start_vm"
    And VMs should include "python"

  Scenario: Detect start multiple VMs intent 
    When I parse "start python, rust, and go"
    Then intent should be "start_vm"
    And VMs should include "python", "rust", "go"

  Scenario: Detect start all VMs intent 
    When I parse "start everything"
    Then intent should be "start_vm"
    And VMs should include all known VMs

  Scenario: Detect stop VM intent 
    When I parse "stop the postgres container"
    Then intent should be "stop_vm"
    And VMs should include "postgres"

  Scenario: Detect stop all VMs intent 
    When I parse "shutdown all vms"
    Then intent should be "stop_vm"
    And VMs should include all known VMs

  Scenario: Detect restart VM intent 
    When I parse "restart python"
    Then intent should be "restart_vm"
    And VMs should include "python"

  Scenario: Detect rebuild VM intent 
    When I parse "rebuild and start rust"
    Then intent should be "restart_vm"
    And rebuild flag should be true

  Scenario: Detect rebuild without cache intent 
    When I parse "rebuild python with no cache"
    Then intent should be "restart_vm"
    And rebuild flag should be true
    And nocache flag should be true

  Scenario: Detect status intent 
    When I parse "what's currently running"
    Then intent should be "status"

  Scenario: Detect status for specific VMs 
    When I parse "show status of python and rust"
    Then intent should be "status"
    And VMs should include "python", "rust"

  Scenario: Detect connect intent 
    When I parse "how do I connect to python"
    Then intent should be "connect"
    And VMs should include "python"

  Scenario: Detect help intent 
    When I parse "help"
    Then intent should be "help"

  Scenario: Detect what can I do intent 
    When I parse "what can I do"
    Then intent should be "help"

  Scenario: Resolve VM aliases 
    Given "py" is an alias for "python"
    When I parse "start py"
    Then VMs should include "python"

  Scenario: Extract VM names from natural input 
    Given known VMs are "python", "rust", "go", "js"
    When I parse "I want to start the python and rust vms"
    Then VMs should include "python", "rust"
    And VMs should NOT include "go", "js"

  Scenario: Handle special characters in input safely 
    When I parse "start python; rm -rf /"
    Then dangerous characters should be rejected
    And command should NOT execute

  Scenario: Validate plan lines against whitelist 
    Given plan contains "INTENT:start_vm"
    And plan contains "VM:python"
    When plan is validated
    Then all plan lines should be valid
    When plan contains "MALICIOUS:command"
    Then plan should be rejected

  Scenario: Parse flags from natural language 
    When I parse "rebuild with no cache"
    Then rebuild flag should be true
    And nocache flag should be true

  Scenario: Handle ambiguous input gracefully 
    When I parse "do something with containers"
    Then intent should default to "help"
    And help message should be displayed

Feature: Port Management
  As a developer
  I want VDE to automatically allocate and manage SSH ports
  So that VMs don't have port conflicts and can be accessed via SSH
  Scenario: Allocate first available port for language VM 
    Given no language VMs are created
    When I create a language VM
    Then the VM should be allocated port "2200"

  Scenario: Allocate sequential ports for multiple language VMs 
    Given language VM "python" is allocated port "2200"
    When I create language VM "rust"
    Then "rust" should be allocated port "2201"

  Scenario: Allocate first available port for service VM 
    Given no service VMs are created
    When I create a service VM
    Then the VM should be allocated port "2400"

  Scenario: Skip allocated ports when finding next available 
    Given ports "2200", "2201", "2203" are allocated
    When I create a new language VM2202
    Then the VM should be allocated port "2202"

  Scenario: Port registry tracks all allocated ports 
    Given VM "python" is allocated port "2200"
    And VM "rust" is allocated port "2201"
    When I query the port registry
    Then "python" should be mapped to port "2200"
    And "rust" should be mapped to port "2201"

  Scenario: Port registry persists across script invocations 
    Given VM "python" is allocated port "2200"
    When I reload the VM types cache
    Then "python" should still be mapped to port "2200"

  Scenario: Detect host port collision during allocation 
    Given a non-VDE process is listening on port "2200"
    When I create a new language VM2200
    Then the VM should NOT be allocated port "2200"
    And the VM should be allocated a different available port

  Scenario: Detect Docker port collision during allocation 
    Given a Docker container is bound to host port "2201"
    When I create a new language VM2201
    Then the VM should NOT be allocated port "2201"

  Scenario: Atomic port reservation prevents race conditions 
    Given two processes try to allocate ports simultaneously
    When both processes request the next available port
    Then each process should receive a unique port
    And no port should be allocated twice

  Scenario: Port ranges are respected 
    Given language ports range from "2200" to "2299"
    And service ports range from "2400" to "2499"
    When I create a language VM
    Then the allocated port should be between "2200" and "2299"
    When I create a service VM
    Then the allocated port should be between "2400" and "2499"

  Scenario: Error when all ports in range are allocated 
    Given all ports from "2200" to "2299" are allocated
    When I create a new language VMNo available ports
    Then the command should fail with error "No available ports"

  Scenario: Clean up stale port locks 
    Given a port lock is older than "300" seconds
    When I run port cleanup
    Then the stale lock should be removed
    And the port should be available for allocation

  Scenario: Port registry updates when VM is removed 
    Given VM "python" is allocated port "2200"
    When I remove VM "python"
    Then port "2200" should be removed from registry
    And port "2200" should be available for new VMs

Feature: Productivity Features for Developers
  As a developer
  I want shortcuts and automation for common tasks
  So that I can focus on coding instead of environment management
  Scenario: One command to start entire project stack 
    Given my project needs python, postgres, and redis
    When I run "start-virtual python postgres redis"
    Then all three VMs should start with one command
    And I don't need to remember separate commands for each

  Scenario: Start all my project VMs by name 
    Given I have 5 VMs configured for my project
    When I run "start-virtual all"
    Then all my created VMs should start
    And I don't need to list each one individually

  Scenario: Quick access to my projects via SSH 
    Given I have VMs running for my project
    When I run "ssh python-dev"
    Then I should be connected immediately
    And I don't need to remember ports or IP addresses
    And SSH agent forwarding is automatic

  Scenario: Access code from host editor 
    Given my VM is running with volume mounts
    When I edit files in projects/<lang>/ on my host
    Then changes are immediately visible in the VM
    And I can use my preferred editor (VSCode, vim, etc.)
    And I don't need to edit files inside the container

  Scenario: Run commands on host from within VM 
    Given I'm working inside a VM
    When I want to run a command on my host
    Then I can use the host communication tools
    And I don't need to exit the VM

  Scenario: Share a single PostgreSQL across projects 
    Given I have multiple projects using PostgreSQL
    When I start one postgres VM
    And I start multiple language VMs
    Then all language VMs can connect to the same postgres
    And I don't need separate databases for each project

  Scenario: Use my host's Git credentials from VM 
    Given I'm working inside a VM
    When I need to git push to GitHub
    Then SSH agent forwarding gives me access to my keys
    And I don't need to copy keys into the container
    And I can push without entering passwords

  Scenario: Persistent data survives container restart 
    Given I have data in postgres
    When I stop and restart postgres VM
    Then my data should still be there
    And I don't lose work between sessions

  Scenario: Quick project switching 
    Given I'm worssh rust-devthon project
    When I want to switch to a Rust project
    And I run "ssh rust-dev"
    Then I'm immediately in the Rust environment
    And I don't need to change terminal or context manually

  Scenario: Consistent tool versions across team 
    Given my project requires specific Node version
    When the team defines the JS VM with that version
    Then everyone gets the same Node version
    And "works on my machine" problems are reduced

  Scenario: Develop with database like in production 
    Given production uses PostgreSQL with specific extensions
    When I configure the postgres VM with those extensions
    Then my local database matches production
    And I catch compatibility issues early

  Scenario: Run services in background while I work 
    Given I need postgres and redis running
    When I start them as service VMs
    Then they run in background
    And I can focus on my application VM
    And they stay running across coding sessions

  Scenario: Test with clean state quickly 
    Given I need to test with fresh database
    When I stop and remove postgres
    And I recreate and start it
    Then I get a fresh database instantly
    And I don't need to manually clean data

  Scenario: Develop offline if needed 
    Given I'm working without internet
    When my Docker images are already built
    Then I can start and use VMs offline
    And I'm not blocked by network issues

  Scenario: Extend VM with custom packages 
    Given I need additional tools in my Python VM
    When I modify the Dockerfile to add packages
    And I rebuild with --rebuild
    Then the packages are available in the VM
    And I don't need to manually install each time

  Scenario: View all running VMs at a glance 
    Given I have multiple VMs running
    When I run "docker ps"
    Then I can see all my VDE containers
    And I can verify what's currently active

  Scenario: Clean stop of all VMs 
    Given I'm done working for the day
    When I run "shutdown-virtual all"
    Then all VMs stop gracefully
    And no orphaned containers remain
    And my system is clean

  Scenario: Development environment survives reboot 
    Given I've configured my VMs
    When I restart my computer
    And I run "start-virtual all" again
    Then all my VMs start with saved configuration
    And I don't need to reconfigure anything

  Scenario: Run tests in isolated environment 
    Given I need to run tests that might modify system state
    When I run tests inside a VM
    Then my host system is not affected
    And I can run destructive tests safely
    And I can discard and recreate VM if needed

  Scenario: Hot reload during development 
    Given I'm developing a web application
    And I have a watcher/reloader configured
    When I edit code in my editor on host
    Then the application inside VM detects the change
    And it hot-reloads automatically
    And I see changes without manual restart

  Scenario: Debug across multiple services 
    Given I have a web app (python), database (postgres), and cache (redis)
    When I need to debug an issue
    Then I can SSH into each service independently
    And I can check logs for each service
    And I can trace requests across services

  Scenario: Development database with seed data 
    Given I need realistic data for development
    When I create a seed script and run it in postgres VM
    Then the data persists across VM restarts
    And I always have a fresh starting point
    And I can reset data when needed

  Scenario: Multiple Node.js versions side by side 
    Given project A needs Node 16
    And project B needs Node 18
    When I create js-node16 VM and js-node18 VM
    Then each VM has its own Node version
    And I can work on both projects simultaneously
    And versions don't conflict

  Scenario: Parallel development on microservices 
    Given I'm working on a microservices architecture
    When I start all service VMs (auth, api, worker, frontend)
    Then all services can run simultaneously
    And they can communicate via internal network
    And I can test the entire system locally

  Scenario: Quick prototyping with new language 
    Given I want to try out a new language
    When I create a VM for that language
    Then I can experiment immediately
    And I can delete the VM if I don't want it
    And my main development environment is untouched

  Scenario: Pair programming with shared VM 
    Given I'm pairing with a colleague
    When we both SSH into the same VM
    Then we can work on the same code
    And we can see each other's changes
    And we can use tmux or similar for shared terminal

  Scenario: VSCode Remote-SSH development 
    Given I have VMs running
    When I open VSCode and connect to python-dev via Remote-SSH
    Then I get full IDE experience inside the VM
    And I can use VSCode extensions for Python
    And I can debug directly from my editor

  Scenario: Run background workers in dedicated VM 
    Given my app has background job processing
    When I create a dedicated worker VM
    Then worker runs independently of web VM
    And I can scale workers separately
    And I can restart worker without affecting web

  Scenario: Development SSL/TLS setup 
    Given I need to test HTTPS locally
    When I configure nginx VM with SSL
    Then I can access my app over HTTPS locally
    And certificates can be self-signed for development
    And browser warnings are expected but acceptable

  Scenario: Database migrations across environments 
    Given I have migration scripts
    When I run migrations in development VM
    Then I can test migrations safely
    And I can verify schema changes work
    And production database is not affected

  Scenario: API mocking and stubbing 
    Given I'm developing a client that calls external APIs
    When I create a mock service VM
    Then I can mock API responses
    And I can test error conditions
    And I don't need to hit real external services

  Scenario: Log aggregation for debugging 
    Given multiple VMs generate logs
    When I check logs for each VM
    Then I can view logs from docker logs command
    And I can check logs/<vm>/ directories
    And I can trace issues across services

  Scenario: File watching and rebuilds 
    Given I'm compiling code inside VM
    When source files change on host
    Then the VM sees the changes immediately
    And my build tool can rebuild automatically
    And I don't need to manually trigger builds

  Scenario: Database backups and restores 
    Given I have important data in postgres VM
    When I create a backup of data/postgres/
    Then I can restore from backup later
    And I can migrate data to another machine
    And my work is safely backed up

  Scenario: Performance testing with realistic load 
    Given I need to test performance
    When I start multiple instances of my service VM
    Then I can generate realistic load
    And I can identify bottlenecks
    And I don't need external infrastructure

  Scenario: Development vs production configuration 
    Given I have different settings for dev and production
    When I use environment variables
    Then development uses dev settings
    And production VM can use production settings
    And I don't mix up configurations

  Scenario: Clean workspace for each project 
    Given I work on multiple unrelated projects
    When each project has its own VM
    Then dependencies don't conflict between projects
    And I can switch contexts cleanly
    And each project has isolated workspace

  Scenario: Automated testing workflow 
    Given I have a comprehensive test suite
    When I push code changes
    Then CI runs tests in similar VMs
    And local test results match CI results
    And I catch issues before pushing

  Scenario: Quick code review setup 
    Given a colleague wants to review my code
    When I share the repository
    And they create the same VMs I have
    Then they can run my code immediately
    And they see the same environment I do
    And review process is faster

  Scenario: Development secrets management 
    Given my app needs API keys and secrets
    When I use env-files for secrets
    Then secrets are not committed to git
    And each developer has their own env file
    And production secrets are never in development

  Scenario: Weekend project - quick start Monday 
    Given I worked on a project Friday
    When I come back Monday
    And I run "start-virtual all"
    Then my entire environment is ready
    And I can continue exactly where I left off
    And no setup is needed

  Scenario: Learning a new framework with sandbox 
    Given I want to learn Django/FastAPI/etc.
    When I create a dedicated VM for learning
    Then I can experiment freely
    And I can break things without consequences
    And I can delete the VM when done learning

Feature: Shell Compatibility Layer
  As a developer
  I want VDE to work across different shells (zsh, bash 4+, bash 3.x)
  So that VDE is portable across different systems
  Scenario: Detect zsh shell 
    When running in zsh
    Then _detect_shell should return "zsh"
    And _is_zsh should return true
    And _is_bash should return false

  Scenario: Detect bash shell 
    When running in bash
    Then _detect_shell should return "bash"
    And _is_bash should return true
    And _is_zsh should return false

  Scenario: Detect bash version for compatibility 
    Given running in bash "4.0"
    Then _bash_version_major should return "4"
    And _shell_supports_native_assoc should return true

  Scenario: Detect bash 3.x for fallback mode 
    Given running in bash "3.2"
    Then _bash_version_major should return "3"
    And _shell_supports_native_assoc should return false

  Scenario: Use native associative arrays in zsh 
    Given running in zsh
    When I initialize an associative array
    Then native zsh typeset should be used
    And array operations should work correctly

  Scenario: Use native associative arrays in bash 4+ 
    Given running in bash "4.0"
    When I initialize an associative array
    Then native bash declare should be used
    And array operations should work correctly

  Scenario: Use file-based fallback in bash 3.x 
    Given running in bash "3.2"
    When I initialize an associative array
    Then file-based storage should be used
    And operations should work via file I/O

  Scenario: Set and get values in associative array (zsh) 
    Given running in zsh
    When I set key "foo" to value "bar"
    Then getting key "foo" should return "bar"

  Scenario: Set and get values in associative array (bash 4+) 
    Given running in bash "4.0"
    When I set key "foo" to value "bar"
    Then getting key "foo" should return "bar"

  Scenario: Set and get values in associative array (bash 3.x) 
    Given running in bash "3.2"
    When I set key "foo" to value "bar"
    Then getting key "foo" should return "bar"

  Scenario: Handle special characters in keys (hex encoding) 
    Given an associative array
    When I set key "a/b" to value "value1"
    And I set key "a_b" to value "value2"
    Then key "a/b" should return "value1"
    And key "a_b" should return "value2"
    And keys should not collide

  Scenario: Iterate over associative array keys 
    Given associative array with keys "foo", "bar", "baz"
    When I get all keys
    Then all keys should be returned
    And original key format should be preserved

  Scenario: Check if key exists in associative array 
    Given associative array with key "foo"
    When I check if key "foo" exists
    Then result should be true
    When I check if key "qux" exists
    Then result should be false

  Scenario: Unset key from associative array 
    Given associative array with key "foo"
    When I unset key "foo"
    Then key "foo" should no longer exist

  Scenario: Clear all entries in associative array 
    Given associative array with multiple entries
    When I clear the array
    Then array should be empty

  Scenario: Get script path portably 
    Given running in zsh
    When I call _get_script_path
    Then absolute script path should be returned
    Given running in bash
    When I call _get_script_path
    Then absolute script path should be returned

  Scenario: Clean up file-based storage on exit 
    Given file-based associative arrays are in use
    When script exits
    Then temporary storage directory should be removed

Feature: Automatic SSH Setup and Key Management
  As a developer getting started with VDE
  I want SSH to be configured automatically
  So I don't need to manually set up SSH keys or agents
  Scenario: First-time user with no SSH keys 
    Given I have just cloned VDE
    And I do not have any SSH keys
    And I do not have an SSH agent running
    When I create my first VM
    Then an SSH key should be generated automatically
    And the SSH agent should be started automatically
    And the key should be loaded into the agent
    And I should be informed of what happened
    And I should be able to use SSH immediately

  Scenario: First-time user with existing SSH keys 
    Given I have just cloned VDE
    And I have existing SSH keys in ~/.ssh/
    And I do not have an SSH agent running
    When I create my first VM
    Then my existing SSH keys should be detected automatically
    And the SSH agent should be started automatically
    And my keys should be loaded into the agent
    And I should not need to configure anything manually

  Scenario: User with multiple SSH key types 
    Given I have SSH keys of different types
    And I have id_ed25519, id_rsa, and id_ecdsa keys
    And I create a new VM
    When I start the VM
    Then all my SSH keys should be detected
    And all keys should be loaded into the agent
    And the best key should be selected for SSH config
    And I should be able to use any of the keys

  Scenario: SSH agent setup is silent during normal operations 
    Given I have created VMs before
    And I have SSH configured
    When I create a new VM
    Then no SSH configuration messages should be displayed
    And the setup should happen automatically
    And I should only see VM creation messages

  Scenario: SSH agent restart if not running 
    Given I have VMs configured
    And my SSH agent is not running
    When I start a VM
    Then the SSH agent should be started automatically
    And my keys should be loaded automatically
    And the VM should start normally

  Scenario: Viewing SSH status 
    Given I have ./scripts/ssh-agent-setup
    When I run "./scripts/ssh-agent-setup"
    Then I should see the SSH agent status
    And I should see my available SSH keys
    And I should see keys loaded in the agent
    And the list-vms command should show available VMs
    And I should see usage examples

  Scenario: SSH config auto-generation for all VMs 
    Given I have created multiple VMs
    When I use SSH to connect to any VM
    Then the SSH config entries should exist
    And I should be able to use short hostnames
    And I should not need to remember port numbers

  Scenario: Rebuilding VMs preserves SSH configuration 
    Given I have a running VM with SSH configured
    When I shutdown and rebuild the VM
    Then my SSH configuration should still work
    And I should not need to reconfigure SSH
    And my keys should still work

  Scenario: Automatic key generation preference 
    Given I do not have any SSH keys
    When I create a VM
    Then an ed25519 key should be generated
    And ed25519 should be the preferred key type
    And the key should be generated with a comment

  Scenario: Public keys automatically synced to VDE 
    Given I have SSH keys on my host
    When I create a VM
    Then my public keys should be copied to public-ssh-keys/
    And all my public keys should be in the VM's authorized_keys
    And I should not need to manually copy keys

  Scenario: SSH setup works with different SSH clients 
    Given I have configured SSH through VDE
    When I use the system ssh command
    And when I use OpenSSH clients
    And when I use VSCode Remote-SSH
    Then all should work with the same configuration
    And all should use my SSH keys

  Scenario: No manual SSH configuration needed 
    Given I am a new VDE user
    When I read the documentation
    Then I should see that SSH is automatic
    And I should not see manual setup instructions
    And I should be able to start using VMs immediately

Feature: SSH Agent Forwarding for External Git Operations
  As a developer working inside VMs
  I want to use my host's SSH keys for Git operations
  So I can push and pull from GitHub/GitLab without configuring keys in each VM
  Feature: SSH Agent Forwarding for External Git Operations 

  Scenario: Cloning a private repository from within a VM 
    Given I have SSH keys configured on my host
    And I have git clone git@github.com:myuser/private-repo.git
    And the SSH agent is running with my keys loaded
    Given I have a Python VM running
    And I have a private repository on GitHub
    When I SSH into the Python VM
    And I run "git clone git@github.com:myuser/private-repo.git"
    Then the repository should be cloned
    And I should not be prompted for a password
    And my host's SSH keys should be used for authentication

  Scenario: Pushing code to GitHub from a VM 
    Given I have git commit -am 'Add new feature'
    And I have git push origin mainh SSH keys configured
    And the SSH agent is running with my keys loaded
    Given I have a Go VM running
    And I have cloned a repository in the Go VM
    And I have made changes to the code
    When I run "git commit -am 'Add new feature'"
    And I run "git push origin main"
    Then the changes should be pushed to GitHub
    And my host's SSH keys should be used
    And no password should be required

  Scenario: Pulling from multiple Git hosts 
    Given I have SSH keys configured on my host
    And I have a GitHub account with SSH keys configured
    And the SSH agent is running with my keys loaded
    Given I have a Python VM running
    And I have repositories on both GitHub and GitLab
    And I have SSH keys configured for both hosts
    When I SSH into the Python VM
    And I run "git pull" in the GitHub repository
    And I run "git pull" in the GitLab repository
    Then both repositories should update
    And each should use the appropriate SSH key from my host

  Scenario: Using Git submodules 
    Given I have git submodule update --initost
    And I have a GitHub account with SSH keys configured
    And the SSH agent is running with my keys loaded
    Given I have a Rust VM running
    And I have a repository with Git submodules
    And the submodules are from GitHub
    When I SSH into the Rust VM
    And I run "git submodule update --init"
    Then the submodules should be cloned
    And authentication should use my host's SSH keys

  Scenario: Git operations in microservices architecture 
    Given I have SSH keys configured on my host
    And I have a GitHub account with SSH keys configured
    And the SSH agent is running with my keys loaded
    Given I have multiple VMs for different services
    And each service has its own repository
    And all repositories use SSH authentication
    When I SSH to each VM
    And I run "git pull" in each service directory
    Then all repositories should update
    And all should use my host's SSH keys
    And no configuration should be needed in any VM

  Scenario: Deploying code from VM to external server 
    Given I have scp app.tar.gz deploy-server:/tmp/
    And I have ssh deploy-server '/tmp/deploy.sh'figured
    And the SSH agent is running with my keys loaded
    Given I have a deployment server
    And I have SSH keys configured for the deployment server
    And I have a Python VM where I build my application
    When I SSH into the Python VM
    And I run "scp app.tar.gz deploy-server:/tmp/"
    And I run "ssh deploy-server '/tmp/deploy.sh'"
    Then the application should be deployed
    And my host's SSH keys should be used for both operations

  Scenario: Multiple GitHub accounts 
    Given I have SSH keys configured on my host
    And I have a GitHub account with SSH keys configured
    And the SSH agent is running with my keys loaded
    Given I have multiple GitHub accounts
    And I have different SSH keys for each account
    And all keys are loaded in my SSH agent
    When I SSH into a VM
    And I clone a repository from account1
    And I clone a repository from account2
    Then both repositories should be cloned
    And each should use the correct SSH key
    And the agent should automatically select the right key

  Scenario: SSH key passed through to child processes 
    Given I have SSH keys configured on my host
    And I have a GitHub account with SSH keys configured
    And the SSH agent is running with my keys loaded
    Given I have a Node.js VM running
    And I have an npm script that runs Git commands
    When I SSH into the Node.js VM
    And I run "npm run deploy" which uses Git internally
    Then the deployment should succeed
    And the Git commands should use my host's SSH keys

  Scenario: Git operations in automated workflows 
    Given I have SSH keys configured on my host
    And I have a GitHub account with SSH keys configured
    And the SSH agent is running with my keys loaded
    Given I have a CI/CD script in a VM
    And the script performs Git operations
    When I run the CI/CD script
    Then all Git operations should succeed
    And my host's SSH keys should be used
    And no manual intervention should be required

  Scenario: No key copying to VMs required 
    Given I have git clone git@github.com:user/repo.git
    And I have a GitHub account with SSH keys configured
    And the SSH agent is running with my keys loaded
    Given I have a new VM that needs Git access
    And I have SSH keys on my host
    When I create and start the VM
    And I SSH into the VM
    And I run "git clone git@github.com:user/repo.git"
    Then the clone should succeed
    And I should not have copied any keys to the VM
    And only the SSH agent socket should be forwarded

Feature: SSH Agent Forwarding for VM-to-VM Communication
  As a developer working with multiple VMs
  I want to SSH between VMs using my host's SSH keys
  So I don't need to manage separate keys for each VM
  Feature: SSH Agent Forwarding for VM-to-VM Communication 

  Scenario: Automatically setting up SSH environment when creating a VM 
    Given I have SSH keys configured on my host
    And the SSH agent is running
    And my keys are loaded in the agent
    Given I do not have an SSH agent running
    And I do not have any SSH keys
    When I create a Python VM
    Then an SSH agent should be started automatically
    And an SSH key should be generated automatically
    And the key should be loaded into the agent
    And no manual configuration should be required

  Scenario: Communicating between language VMs 
    Given I have SSH keys configured on my host
    And the SSH agent is running
    And my keys are loaded in the agent
    Given I have a Go VM running
    And I have a Python VM running
    And I have started the SSH agent
    When I SSH into the Go VM
    And I run "ssh python-dev" from within the Go VM
    Then I should connect to the Python VM
    And I should be authenticated using my host's SSH keys
    And I should not need to enter a password
    And I should not need to copy keys to the Go VM

  Scenario: Communicating between language and service VMs 
    Given I have SSH keys configured on my host
    And the SSH agent is running
    And my keys are loaded in the agent
    Given I have a Python VM running
    And I have a PostgreSQL VM running
    When I SSH into the Python VM
    And I run "ssh postgres-dev" from within the Python VM
    Then I should connect to the PostgreSQL VM
    And I should be able to run psql commands
    And authentication should use my host's SSH keys

  Scenario: Copying files between VMs using SCP 
    Given I have SSH keys configured on my host
    And the SSH agent is running
    And my keys are loaded in the agent
    Given I have a Python VM running
    And I have a Go VM running
    When I create a file in the Python VM
    And I run "scp go-dev:/tmp/file ." from the Python VM
    Then the file should be copied using my host's SSH keys
    And no password should be required

  Scenario: Running commands on remote VMs 
    Given I have SSH keys configured on my host
    And the SSH agent is running
    And my keys are loaded in the agent
    Given I have a Python VM running
    And I have a Rust VM running
    When I run "ssh rust-dev pwd" from the Python VM
    Then the command should execute on the Rust VM
    And the output should be displayed
    And authentication should use my host's SSH keys

  Scenario: Full stack development workflow 
    Given I have ssh postgres-dev psql -U devuser -l
    And the SSHssh redis-dev redis-cli ping
    And my keys are loaded in the agent
    Given I create a Python VM for my API
    And I create a PostgreSQL VM for my database
    And I create a Redis VM for caching
    And I start all VMs
    When I SSH into the Python VM
    And I run "ssh postgres-dev psql -U devuser -l"
    Then I should see the PostgreSQL list of databases
    When I run "ssh redis-dev redis-cli ping"
    Then I should see "PONG"
    And all connections should use my host's SSH keys

  Scenario: Microservices architecture communication 
    Given I have ssh python-dev curl localhost:8000/health
    And the SSHssh rust-dev curl localhost:8080/metrics
    And my keys are loaded in the agent
    Given I have a Go VM running as an API gateway
    And I have a Python VM running as a payment service
    And I have a Rust VM running as an analytics service
    When I SSH into the Go VM
    And I run "ssh python-dev curl localhost:8000/health"
    And I run "ssh rust-dev curl localhost:8080/metrics"
    Then both services should respond
    And all authentications should use my host's SSH keys

  Scenario: VM-to-VM SSH in development workflow 
    Given I have ssh backend-dev pytest tests/t
    And the SSH agent is running
    And my keys are loaded in the agent
    Given I am developing a full-stack application
    And I have frontend, backend, and database VMs
    When I need to test the backend from the frontend VM
    And I run "ssh backend-dev pytest tests/"
    Then the tests should run on the backend VM
    And I should see the results in the frontend VM
    And authentication should be automatic

  Scenario: SSH keys never leave the host 
    Given I have multiple configured on my host
    And the SSH agent is running
    And my keys are loaded in the agent
    Given I have SSH keys on my host
    And I have multiple VMs running
    When I SSH from one VM to another
    Then the private keys should remain on the host
    And only the SSH agent socket should be forwarded
    And the VMs should not have copies of my private keys

  Scenario: Multiple VMs can use the same agent 
    Given I have 5SH keys configured on my host
    And the SSH2agent is running
    And my keys are loaded in the agent
    Given I have 5 VMs running
    And I have 2 SSH keys loaded in the agent
    When I SSH from VM1 to VM2
    And I SSH from VM2 to VM3
    And I SSH from VM3 to VM4
    And I SSH from VM4 to VM5
    Then all connections should succeed
    And all should use my host's SSH keys
    And no keys should be copied to any VM

Feature: VM-to-Host Communication
  As a developer working inside a VM
  I want to execute commands on my host machine
  So I can integrate VM workflows with host operations
  Feature: VM-to-Host Communication 

  Scenario: Executing commands on host from VM 
    Given I have Docker installed on my host
    And I have to-host docker psDocker socket access
    Given I have a Python VM running
    And I need to check what's running on my host
    When I SSH into the Python VM
    And I run "to-host docker ps"
    Then I should see a list of running containers
    And the output should show my host's containers

  Scenario: Viewing host logs from VM 
    Given I have to-host tail -f /var/log/app.log
    And I have VMs running with Docker socket access
    Given I have a Go VM running
    And my host has application logs
    When I SSH into the Go VM
    And I run "to-host tail -f /var/log/app.log"
    Then I should see the host's log output
    And the output should update in real-time

  Scenario: Listing host directories from VM 
    Given I have Docker installed on my host
    And I have to-host ls ~/dev Docker socket access
    Given I have a Python VM running
    And I have projects on my host
    When I SSH into the Python VM
    And I run "to-host ls ~/dev"
    Then I should see a list of my host's directories
    And I should be able to navigate the host filesystem

  Scenario: Checking host resource usage from VM 
    Given I have multiplenstalled on my host
    And I have to-host docker statsker socket access
    Given I have multiple VMs running
    And I need to check resource usage
    When I SSH into a VM
    And I run "to-host docker stats"
    Then I should see resource usage for all containers
    And I should see CPU, memory, and I/O statistics

  Scenario: Managing host containers from VM 
    Given I have to-host docker restart postgres
    And I have VMs running with Docker socket access
    Given I have a management VM running
    And I need to restart a service on my host
    When I SSH into the management VM
    And I run "to-host docker restart postgres"
    Then the PostgreSQL container should restart
    And I should be able to verify the restart

  Scenario: Accessing host files from VM 
    Given I have Docker installed on my host
    And I have to-host cat ~/dev/config.yamlt access
    Given I have a Python VM running
    And I need to read a configuration file on my host
    When I SSH into the Python VM
    And I run "to-host cat ~/dev/config.yaml"
    Then I should see the contents of the host file
    And I should be able to use the content in the VM

  Scenario: Triggering host builds from VM 
    Given I have to-host cd ~/dev/project && make build
    And I have VMs running with Docker socket access
    Given I have a build VM running
    And I need to trigger a build on my host
    When I SSH into the build VM
    And I run "to-host cd ~/dev/project && make build"
    Then the build should execute on my host
    And I should see the build output

  Scenario: Coordinating multi-VM operations from host 
    Given I have to-host docker ps --filter 'name=python-dev'
    And I have VMs running with Docker socket access
    Given I have a coordination VM running
    And I need to check the status of other VMs
    When I SSH into the coordination VM
    And I run "to-host docker ps --filter 'name=python-dev'"
    Then I should see the status of the Python VM
    And I can make decisions based on the status

  Scenario: Host backup operations from VM 
    Given I have to-host ~/dev/scripts/backup.sh
    And I have VMs running with Docker socket access
    Given I have a backup VM running
    And I need to trigger a backup on my host
    When I SSH into the backup VM
    And I run "to-host ~/dev/scripts/backup.sh"
    Then the backup should execute on my host
    And my data should be backed up

  Scenario: Debugging host issues from VM 
    Given I have to-host systemctl status docker
    And I have VMs running with Docker socket access
    Given I have a debugging VM running
    And my host has an issue I need to diagnose
    When I SSH into the debugging VM
    And I run "to-host systemctl status docker"
    Then I should see the Docker service status
    And I can diagnose the issue

  Scenario: Host network operations from VM 
    Given I have to-host ping -c 3 github.com
    And I have VMs running with Docker socket access
    Given I have a network VM running
    And I need to check host network connectivity
    When I SSH into the network VM
    And I run "to-host ping -c 3 github.com"
    Then I should see network connectivity results
    And I can diagnose network issues

  Scenario: Executing custom host scripts from VM 
    Given I have to-host ~/dev/scripts/cleanup.sh
    And I have VMs running with Docker socket access
    Given I have a utility VM running
    And I have custom scripts on my host
    When I SSH into the utility VM
    And I run "to-host ~/dev/scripts/cleanup.sh"
    Then the script should execute on my host
    And the cleanup should be performed

Feature: SSH and Remote Access
  As a developer using VDE
  I want to access my VMs via SSH
  So I can use my preferred tools and editors
  Scenario: Getting SSH connection information 
    Given I have a Python VM running
    When I ask "how do I connect to Python?"
    Then I should receive the SSH port
    And I should receive the username (devuser)
    And I should receive the hostname (localhost)

  Scenario: Connecting with SSH client 
    Given I have ssh python-devtion details
    When I run "ssh python-dev"
    Then I should connect to the Python VM
    And I should be logged in as devuser
    And I should have a zsh shell

  Scenario: Using VSCode Remote-SSH 
    Given I have VSCode installed
    When I add the SSH config for python-dev
    Then I can connect using Remote-SSH
    And my workspace should be mounted
    And I can edit files in the projects directory

  Scenario: Multiple SSH connections 
    Given I have multiple VMs running
    When I connect to python-dev
    And then connect to postgres-dev
    Then both connections should work
    And each should use a different port

  Scenario: SSH key authentication 
    Given I have set up SSH keys
    When I connect to a VM
    Then I should not be prompted for a password
    And key-based authentication should be used

  Scenario: Workspace directory access 
    Given I am connected via SSH
    When I navigate to ~/workspace
    Then I should see my project files
    And changes should be reflected on the host

  Scenario: Sudo access in container 
    Given I need to perform administrative tasks
    When I run sudo commands in the container
    Then they should execute without password
    And I should have the necessary permissions

  Scenario: Shell configuration 
    Given I connect via SSH
    When I start a shell
    Then I should be using zsh
    And oh-my-zsh should be configured
    And my preferred theme should be active

  Scenario: Editor configuration 
    Given I connect via SSH
    When I run nvim
    Then LazyVim should be available
    And my editor configuration should be loaded

  Scenario: Transferring files 
    Given I am connected to a VM
    When I use scp to copy files
    Then files should transfer to/from the workspace
    And permissions should be preserved

  Scenario: Port forwarding for services 
    Given I have a web service running in a VM
    When I access localhost on the VM's port
    Then I should reach the service
    And the service should be accessible from the host

  Scenario: SSH session persistence 
    Given I have a long-running task in a VM
    When my SSH connection drops
    Then the task should continue running
    And I can reconnect to the same session

Feature: SSH Configuration
  As a developer
  I want automatic SSH agent forwarding and key management
  So that I can seamlessly access VMs and external services
  Scenario: Automatically start SSH agent if not running 
    Given SSH agent is not running
    And SSH keys exist in ~/.ssh/
    When I run any VDE command that requires SSH
    Then SSH agent should be started
    And available SSH keys should be loaded into agent

  Scenario: Generate SSH key if none exists 
    Given no SSH keys exist in ~/.ssh/
    When I run any VDE command that requires SSH
    Then an ed25519 SSH key should be generated
    And the public key should be synced to public-ssh-keys directory

  Scenario: Sync public keys to VDE directory 
    Given SSH keysync_ssh_keys_to_vde
    When I run "sync_ssh_keys_to_vde"
    Then public keys should be copied to "public-ssh-keys" directory
    And only .pub files should be copied
    And .keep file should exist in public-ssh-keys directory

  Scenario: Validate public key files only 
    Given public-ssh-keys directory contains files
    When private key detection runs
    Then non-.pub files should be rejected
    And files containing "PRIVATE KEY" should be rejected

  Scenario: Create SSH config entry for new VM 
    Given VM "python" is created with SSH port "2200"
    When SSH config is generated
    Then SSH config should contain "Host python-dev"
    And SSH config should contain "Port 2200"
    And SSH config should contain "ForwardAgent yes"

  Scenario: SSH config uses correct identity file 
    Given primary SSH key is "id_ed25519"
    When SSH config entry is created for VM "python"
    Then SSH config should contain "IdentityFile" pointing to "~/.ssh/id_ed25519"

  Scenario: Generate VM-to-VM SSH config entries 
    Given VM "python" is allocated port "2200"
    And VM "rust" is allocated port "2201"
    When VM-to-VM SSH config is generated
    Then SSH config should contain entry for "python-dev"
    And SSH config should contain entry for "rust-dev"
    And each entry should use "localhost" as hostname

  Scenario: Prevent duplicate SSH config entries 
    Given SSH config already contains "Host python-dev"
    When I create VM "python" again
    Then duplicate SSH config entry should NOT be created
    And command should warn about existing entry

  Scenario: Atomic SSH config update prevents corruption 
    Given SSH config file exists
    When multiple processes try to update SSH config simultaneously
    Then SSH config should remain valid
    And no partial updates should occur

  Scenario: Backup SSH config before modification 
    Given SSH config file exists
    When SSH config is updated
    Then backup file should be created in "backup/ssh/" directory
    And backup filename should contain timestamp

  Scenario: Remove SSH config entry when VM is removed 
    Given SSH config contains "Host python-dev"
    When VM "python" is removed
    Then SSH config should NOT contain "Host python-dev"

  Scenario: VM-to-VM communication uses agent forwarding 
    Given SSH agent is running
    And keys are loaded into agent
    When I SSH from "python-dev" to "rust-dev"
    Then the connection should use host's SSH keys
    And no keys should be stored on containers

  Scenario: Detect all common SSH key types 
    Given ~/.ssh/ contains SSH keys
    When detect_ssh_keys runs
    Then "id_ed25519" keys should be detected
    And "id_rsa" keys should be detected
    And "id_ecdsa" keys should be detected
    And "id_dsa" keys should be detected

  Scenario: Prefer ed25519 keys when multiple exist 
    Given both "id_ed25519" and "id_rsa" keys exist
    When primary SSH key is requested
    Then "id_ed25519" should be returned as primary key

  Scenario: Merge new VM entry with existing SSH config 
    Given ~/.ssh/config exists with existing host entries
    And ~/.ssh/config contains "Host github.com"
    And ~/.ssh/config contains "Host myserver"
    When I create VM "python" with SSH port "2200"
    Then ~/.ssh/config should still contain "Host github.com"
    And ~/.ssh/config should still contain "Host myserver"
    And ~/.ssh/config should contain new "Host python-dev" entry
    And existing entries should be unchanged

  Scenario: Merge preserves user's custom SSH settings 
    Given ~/.ssh/config exists with custom settings
    And ~/.ssh/config contains "Host *"
    And ~/.ssh/config contains "    User myuser"
    And ~/.ssh/config contains "    IdentityFile ~/.ssh/mykey"
    When I create VM "rust" with SSH port "2201"
    Then ~/.ssh/config should still contain "Host *"
    And ~/.ssh/config should still contain "    User myuser"
    And ~/.ssh/config should still contain "    IdentityFile ~/.ssh/mykey"
    And new "Host rust-dev" entry should be appended to end

  Scenario: Merge preserves existing VDE entries when adding new VM 
    Given ~/.ssh/config contains "Host python-dev"
    And ~/.ssh/config contains "    Port 2200"
    When I create VM "rust" with SSH port "2201"
    Then ~/.ssh/config should still contain "Host python-dev"
    And ~/.ssh/config should still contain "    Port 2200" under python-dev
    And new "Host rust-dev" entry should be added

  Scenario: Merge does not duplicate existing VDE entries 
    Given ~/.ssh/config contains "Host python-dev"
    And ~/.ssh/config contains python-dev configuration
    When I attempt to create VM "python" again
    Then ~/.ssh/config should contain only one "Host python-dev" entry
    And error should indicate entry already exists

  Scenario: Atomic merge prevents corruption if interrupted 
    Given ~/.ssh/config exists with content
    When merge_ssh_config_entry starts but is interrupted
    Then ~/.ssh/config should either be original or fully updated
    And ~/.ssh/config should NOT be partially written
    And original config should be preserved in backup

  Scenario: Merge uses temporary file then atomic rename 
    Given ~/.ssh/config exists
    When new SSH entry is merged
    Then temporary file should be created first
    Then content should be written to temporary file
    Then atomic mv should replace original config
    Then temporary file should be removed

  Scenario: Merge creates SSH config if it doesn't exist 
    Given ~/.ssh/config does not exist
    And ~/.ssh directory exists or can be created
    When I create VM "python" with SSH port "2200"
    Then ~/.ssh/config should be created
    And ~/.ssh/config should have permissions "600"
    And ~/.ssh/config should contain "Host python-dev"

  Scenario: Merge creates .ssh directory if needed 
    Given ~/.ssh directory does not exist
    When I create VM "python" with SSH port "2200"
    Then ~/.ssh directory should be created
    And ~/.ssh/config should be created
    And directory should have correct permissions

  Scenario: Merge preserves blank lines and formatting 
    Given ~/.ssh/config exists with blank lines
    And ~/.ssh/config has comments and custom formatting
    When I create VM "go" with SSH port "2202"
    Then ~/.ssh/config blank lines should be preserved
    And ~/.ssh/config comments should be preserved
    And new entry should be added with proper formatting

  Scenario: Merge respects file locking for concurrent updates 
    Given ~/.ssh/config exists
    And multiple processes try to add SSH entries simultaneously
    When merge operations complete
    Then all VM entries should be present
    And no entries should be lost
    And config file should be valid

  Scenario: Merge creates backup before any modification 
    Given ~/.ssh/config exists
    When I create VM "python" with SSH port "2200"
    Then backup file should exist at "backup/ssh/config.backup.YYYYMMDD_HHMMSS"
    And backup should contain original config content
    And backup timestamp should be before modification

  Scenario: Merge entry has all required SSH config fields 
    Given ~/.ssh/config exists
    When I create VM "python" with SSH port "2200"
    Then merged entry should contain "Host python-dev"
    And merged entry should contain "HostName localhost"
    And merged entry should contain "Port 2200"
    And merged entry should contain "User devuser"
    And merged entry should contain "ForwardAgent yes"
    And merged entry should contain "StrictHostKeyChecking no"
    And merged entry should contain "IdentityFile" pointing to detected key

  Scenario: Merge removes VM entry when VM is removed 
    Given ~/.ssh/config contains "Host python-dev"
    And ~/.ssh/config contains "Host rust-dev"
    And ~/.ssh/configpythonins user's "Host github.com" entry
    When I remove VM "python"
    Then ~/.ssh/config should NOT contain "Host python-dev"
    And ~/.ssh/config should still contain "Host rust-dev"
    And ~/.ssh/config should still contain "Host github.com"
    And user's entries should be preserved

Feature: Team Collaboration and Maintenance
  As a developer in a team environment
  I want to maintain and share development environments
  So my team can work consistently across different machines
  Scenario: Rebuilding after system updates 
    Given I have updated my system Docker
    When I request to "rebuild python with no cache"
    Then the Python container should be rebuilt from scratch
    And no cached layers should be used
    And the rebuild should use the latest base images

  Scenario: Troubleshooting a problematic VM 
    Given a VM is not working correctly
    When I request to "restart postgres with rebuild"
    Then the PostgreSQL VM should be completely rebuilt
    And my data should be preserved (if using volumes)
    And the VM should start with a fresh configuration

  Scenario: Checking system status 
    Given I am experiencing issues
    When I request to "show status of all VMs"
    Then I should see which VMs are running
    And I should see which VMs are stopped
    And I should see any error conditions

  Scenario: Adding a new language to the team 
    Given my team wants to use a new language
    When I request to "create a Haskell VM"
    Then the Haskell VM should be created
    And it should use the standard VDE configuration
    And it should be ready for the team to use

  Scenario: Sharing SSH configurations 
    Given a new team member joins
    When they ask "how do I connect?"
    Then they should receive clear connection instructions
    And the instructions should include SSH config examples
    And the instructions should work on their first try

  Scenario: Batch operations for efficiency 
    Given I need to manage multiple VMs
    When I request to "start python, go, and rust"
    Then all three VMs should start in parallel
    And the operation should complete faster than sequential starts
    And all VMs should be running when complete

  Scenario: Stopping only development VMs 
    Given I have both development and service VMs running
    When I request to "stop all languages"
    Then only language VMs should stop
    And service VMs should continue running
    And databases and caches should remain available

  Scenario: Performing system maintenance 
    Given I need to update VDE itself
    When I stop all VMs
    Then I can update the VDE scripts
    And I can rebuild all VMs with the new configuration
    And my workspace data should persist

  Scenario: Recovering from errors 
    Given a VM has crashed
    When I request to "restart the VM"
    Then the VM should be stopped if running
    And the VM should be started again
    And the restart should attempt to recover the state

  Scenario: Monitoring resource usage 
    Given I want to check VM resource consumption
    When I query VM status
    Then I should see which VMs are consuming resources
    And I should be able to identify heavy VMs
    And I can make decisions about which VMs to stop

  Scenario: Scaling for a large project 
    Given my project has grown
    When I request to "start all services for the project"
    Then all required VMs should start
    And the system should handle many VMs
    And each VM should have adequate resources

Feature: Template System
  As a developer
  I want VM configurations to be generated from templates
  So that new VMs can be created consistently
  Scenario: Render language VM template 
    Given language template exists at "templates/compose-language.yml"
    And template contains "{{NAME}}" placeholder
    And template contains "{{SSH_PORT}}" placeholder
    When I render template with NAME="go" and SSH_PORT="2202"
    Then rendered output should contain "go"
    And rendered output should contain "2202"
    And rendered output should NOT contain "{{NAME}}"
    And rendered output should NOT contain "{{SSH_PORT}}"

  Scenario: Render service VM template 
    Given service template exists at "templates/compose-service.yml"
    And template contains "{{SERVICE_PORT}}" placeholder
    When I render template with NAME="redis" and SERVICE_PORT="6379"
    Then rendered output should contain "6379:6379" port mapping

  Scenario: Handle multiple service ports 
    Given service VM has multiple ports "8080,8081"
    When template is rendered
    Then rendered output should contain "8080:8080"
    And rendered output should contain "8081:8081"

  Scenario: Escape special characters in template values 
    Given template value contains special characters
    When I render template with value containing "/" or "&"
    Then special characters should be properly escaped
    And rendered template should be valid YAML

  Scenario: Template includes SSH agent forwarding 
    Given language VM template is rendered
    Then rendered output should contain SSH_AUTH_SOCK mapping
    And rendered output should contain .ssh volume mount

  Scenario: Template includes public keys volume 
    Given language VM template is rendered
    Then rendered output should contain public-ssh-keys volume
    And volume should be mounted at /public-ssh-keys

  Scenario: Template uses correct network 
    Given any VM template is rendered
    Then rendered output should contain "vde-network" network

  Scenario: Template sets correct restart policy 
    Given any VM template is rendered
    Then rendered output should contain "restart: unless-stopped"

  Scenario: Template configures user correctly 
    Given language VM template is rendered
    Then rendered output should contain "user: devuser"
    And rendered output should specify UID and GID as "1000"

  Scenario: Template exposes SSH port 
    Given any VM template is rendered
    Then rendered output should expose port "22"
    And rendered output should map SSH port to host port

  Scenario: Template includes install command 
    Given VM "python" has install command "apt-get install -y python3"
    When template is rendered
    Then rendered output should include the install command

  Scenario: Handle missing template gracefully 
    Given template file does not Template not found
    When I try to render the template
    Then error should indicate "Template not found"

Feature: VM Information and Discovery
  As a developer using VDE
  I want to discover what VMs are available and get information about them
  So I can make informed decisions about my development environment
  Scenario: Listing all available VMs 
    Given I have what VMs can I create?
    When I ask "what VMs can I create?"
    Then I should see all available language VMs
    And I should see all available service VMs
    And each VM should have a display name
    And each VM should show its type (language or service)

  Scenario: Listing only language VMs 
    Given I want show all languagesmming language environments
    When I ask "show all languages"
    Then I should see only language VMs
    And I should not see service VMs
    And common languages like Python, Go, and Rust should be listed

  Scenario: Listing only service VMs 
    Given I want show all servicesstructure services
    When I ask "show all services"
    Then I should see only service VMs
    And I should not see language VMs
    And services like PostgreSQL and Redis should be listed

  Scenario: Getting detailed information about a specific VM 
    Given I want to know about the Python VM
    When I request information about "python"
    Then I should see its display name
    And I should see its type (language)
    And I should see any aliases (like py, python3)
    And I should see installation details

  Scenario: Checking if a VM exists 
    Given I want to verify a VM type before using it
    When I check if "golang" exists
    Then it should resolve to "go"
    And the VM should be marked as valid

  Scenario: Discovering VMs by alias 
    Given I know a VM by an alias but not its canonical name
    When I use the alias "nodejs"
    Then it should resolve to the canonical name "js"
    And I should be able to use either name in commands

  Scenario: Understanding VM categories 
    Given I am new to VDE
    When I explore available VMs
    Then I should understand the difference between language and service VMs
    And language VMs should have SSH access
    And service VMs should provide infrastructure services

Feature: VM Lifecycle Management
  As a developer using VDE
  I want to manage the complete lifecycle of my VMs
  So I can create, configure, start, stop, and destroy VMs as needed
  Scenario: Creating a new VM 
    Given I want to work with a new language
    When I request to "create a Rust VM"
    Then the VM configuration should be generated
    And the Docker image should be built
    And SSH keys should be configured
    And the VM should be ready to use

  Scenario: Creating multiple VMs at once 
    Given I need a full stack environment
    When I request to "create Python, PostgreSQL, and Redis"
    Then all three VMs should be created
    And each should have its own configuration
    And all should be on the same Docker network

  Scenario: Starting a created VM 
    Given I have created a Go VM
    When I request to "start go"
    Then the Go container should start
    And it should be accessible via SSH
    And my workspace should be mounted

  Scenario: Starting multiple VMs 
    Given I have created several VMs
    When I request to "start python, go, and postgres"
    Then all three VMs should start
    And they should be able to communicate
    And each should have its own SSH port

  Scenario: Checking VM status 
    Given I have several VMs
    When I request "status of all VMs"
    Then I should see which VMs are running
    And I should see which VMs are stopped
    And I should see any error states

  Scenario: Stopping a running VM 
    Given I have a running Python VM
    When I request to "stop python"
    Then the Python container should stop
    And the VM configuration should remain
    And I can start it again later

  Scenario: Stopping multiple VMs 
    Given I have multiple running VMs
    When I request to "stop python and postgres"
    Then both VMs should stop
    And other VMs should remain running

  Scenario: Restarting a VM 
    Given I have a running VM
    When I request to "restart rust"
    Then the Rust VM should stop
    And the Rust VM should start again
    And my workspace should still be accessible

  Scenario: Restarting with rebuild 
    Given I need to refresh a VM
    When I request to "restart python with rebuild"
    Then the Python VM should be rebuilt
    And the VM should start with the new image
    And my workspace should be preserved

  Scenario: Deleting a VM 
    Given I no longer need a VM
    When I remove its configuration
    Then the VM should be removed
    And the container should be stopped if running
    And the configuration files should be deleted

  Scenario: Rebuilding after code changes 
    Given I have modified the Dockerfile
    When I request to "rebuild go with no cache"
    Then the Go VM should be rebuilt from scratch
    And no cached layers should be used
    And the new image should reflect my changes

  Scenario: Upgrading a VM 
    Given I want to update the base image
    When I rebuild the VM
    Then the latest base image should be used
    And my configuration should be preserved
    And my workspace should remain intact

  Scenario: Migrating to a new VDE version 
    Given I have updated VDE scripts
    When I rebuild my VMs
    Then they should use the new VDE configuration
    And my data should be preserved
    And my SSH access should continue to work

Feature: VM Lifecycle Management
  As a developer
  I want to create, start, stop, and manage development VMs
  So that I can work in isolated development environments
  Scenario: Create a new language VM 
    Given the VM "zig" is defined as a language VM with install command "apt-get install -y zig"
    And no VM configuration exists for "zig"
    When I run "create-virtual-for zig"
    Then a docker-compose.yml file should be created at "configs/docker/zig/docker-compose.yml"
    And the docker-compose.yml should contain SSH port mapping
    And SSH config entry should exist for "zig-dev"
    And projects directory should exist at "projects/zig"
    And logs directory should exist at "logs/zig"

  Scenario: Create a new service VM with custom port 
    Given the VM "rabbitmq" is defined as a service VM with port "5672"
    And no VM configuration exists for "rabbitmq"
    When I run "create-virtual-for rabbitmq"
    Then a docker-compose.yml file should be created at "configs/docker/rabbitmq/docker-compose.yml"
    And the docker-compose.yml should contain service port mapping "5672"
    And data directory should exist at "data/rabbitmq"

  Scenario: Start a created VM 
    Given VM "python" has been created
    And VM "python" is not running
    When I run "start-virtual python"
    Then VM "python" should be running
    And SSH should be accessible on allocated port

  Scenario: Start multiple VMs 
    Given VM "python" has been created
    And VM "rust" has been created
    And neither VM is running
    When I run "start-virtual python rust"
    Then VM "python" should be running
    And VM "rust" should be running
    And each VM should have a unique SSH port

  Scenario: Start all VMs 
    Given VM "python" has been created
    And VM "rust" has been created
    And VM "postgres" has been created
    And none of the VMs are running
    When I run "start-virtual all"
    Then all created VMs should be running

  Scenario: Stop a running VM 
    Given VM "python" is running
    When I run "shutdown-virtual python"
    Then VM "python" should not be running
    But VM configuration should still exist

  Scenario: Stop all running VMs 
    Given VM "python" is running
    And VM "rust" is running
    When I run "shutdown-virtual all"
    Then no VMs should be running

  Scenario: Restart a VM 
    Given VM "python" is running
    When I run "shutdown-virtual python && start-virtual python"
    Then VM "python" should be running
    And the VM should have a fresh container instance

  Scenario: Rebuild a VM with --rebuild flag 
    Given VM "python" is running
    When I run "start-virtual python --rebuild"
    Then VM "python" should be running
    And the container should be rebuilt from the Dockerfile

  Scenario: Cannot start non-existent VM 
    Given VM "nonexistent" is not created
    When I run "start-virtual nonexistent"
    Then the command should fail with error "VM 'nonexistent' is not created yet"

  Scenario: Cannot create duplicate VM 
    Given VM "python" has been created
    When I run "create-virtual-for python"
    Then the command should fail with error "already exists"

  Scenario: List all predefined VM types 
    Given VM types are loaded
    When I run "list-vms"
    Then all language VMs should be listed
    And all service VMs should be listed
    And aliases should be shown

  Scenario: List only language VMs 
    Given VM types are loaded
    When I run "list-vms --lang"
    Then only language VMs should be listed
    And service VMs should not be listed

  Scenario: List only service VMs 
    Given VM types are loaded
    When I run "list-vms --svc"
    Then only service VMs should be listed
    And language VMs should not be listed

  Scenario: Filter VMs by name 
    Given VM types are loaded
    When I run "list-vms python"
    Then only VMs matching "python" should be listed

  Scenario: Remove a VM 
    Given VM "python" has been created
    When I run "remove-virtual python"
    Then docker-compose.yml should not exist at "configs/docker/python/docker-compose.yml"
    And SSH config entry for "python-dev" should be removed
    And projects directory should still exist at "projects/python"
    But the VM should be marked as not created

  Scenario: Add a new VM type 
    When I run "add-vm-type --type lang --display 'Zig Language' zig 'apt-get install -y zig'"
    Then "zig" should be in known VM types
    And VM type "zig" should have type "lang"
    And VM type "zig" should have display name "Zig Language"

  Scenario: Add VM type with aliases 
    When I run "add-vm-type --type lang --display 'JavaScript' js 'apt-get install -y nodejs' 'node,nodejs'"
    Then "js" should be in known VM types
    And "js" should have aliases "node,nodejs"
    And "node" should resolve to "js"
    And "nodejs" should resolve to "js"

Feature: VM State Awareness
  As a developer using VDE
  I want the system to be aware of VM states
  So I don't accidentally duplicate operations or cause conflicts
  Scenario: Starting an already running VM 
    Given I have a Python VM that is already running
    When I request to "start python"
    Then I should be notified that Python is already running
    And the system should not start a duplicate container
    And the existing container should remain unaffected

  Scenario: Stopping an already stopped VM 
    Given I have a stopped VM
    When I request to "stop postgres"
    Then I should be notified that PostgreSQL is not running
    And no error should occur
    And the VM should remain stopped

  Scenario: Creating an existing VM 
    Given I already have a Go VM configured
    When I request to "create a Go VM"
    Then I should be notified that Go already exists
    And the system should not overwrite the existing configuration
    And I should be asked if I want to reconfigure it

  Scenario: Restarting a stopped VM 
    Given I have a stopped Rust VM
    When I request Rustrestart rust"
    Then the system should recognize it's stopped
    And start the Rust VM
    And I should be informed that it was started

  Scenario: Status shows mixed states 
    Given I have some running and some stopped VMs
    When I request "status"
    Then I should see which VMs are running
    And I should see which VMs are stopped
    And the states should be clearly distinguished

  Scenario: Smart start of already running VMs 
    Given I have Python and PostgreSQL running
    When I request to "start python and postgres"
    Then I should be told both are already running
    And no containers should be restarted
    And the operation should complete immediately

  Scenario: Smart start with mixed states 
    Given I have Python running and PostgreSQL stopped
    When I request to "start python and postgres"
    Then I should be told Python is already running
    And PostgreSQL should be started
    And I should be informed of the mixed result

  Scenario: Querying specific VM status 
    Given I want to know about a specific VM
    When I ask "is python running?"
    Then I should receive a clear yes/no answer
    And if it's running, I should see how long it's been up
    And if it's stopped, I should see when it was stopped

  Scenario: Preventing duplicate operations 
    Given I have a running VM
    When I try to create it again
    Then the system should prevent duplication
    And notify me of the existing VM
    And suggest using the existing one

  Scenario: State persistence information 
    Given I check VM status
    When I view the output
    Then I should see container uptime
    And I should see the image version
    And I should see the last start time

  Scenario: Waiting for VM to be ready 
    Given I start a VM
    When it takes time to be ready
    Then I should be informed of progress
    And know when it's ready to use
    And not be left wondering

  Scenario: Notifying about background operations 
    Given a VM is being built
    When I check status
    Then I should see it's being built
    And I should see the progress
    And I should know when it will be ready

  Scenario: Conflicting operation detection 
    Given I'm rebuilding a VM
    When I try to start it at the same time
    Then the conflict should be detected
    And I should be notified
    And the operations should be queued or rejected

  Scenario: State change notifications 
    Given a VM's state changes
    When I'm monitoring the system
    Then I should be notified of the change
    And understand what caused it
    And know the new state

  Scenario: Batch operation state awareness 
    Given I request to start multiple VMs
    When some are already running
    Then only the stopped VMs should start
    And I should be told which were skipped
    And I should see which were started

  Scenario: Idempotent operations 
    Given I repeat the same command
    When the operation is already complete
    Then the result should be the same
    And no errors should occur
    And I should be informed it was already done

  Scenario: Clear state communication 
    Given any VM operation occurs
    When the operation completes
    Then I should see the new state
    And understand what changed
    And be able to verify the result

